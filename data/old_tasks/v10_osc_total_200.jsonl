{"task_id": "v10_osc_backpressure_001", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_1():\n    q = BackpressureQueue(3)\n    assert q.offer(11) is True\n    assert q.offer(12) is True\n    assert q.offer(13) is True\n    assert q.poll() == 11\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_002", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_2():\n    q = BackpressureQueue(4)\n    assert q.offer(21) is True\n    assert q.offer(22) is True\n    assert q.offer(23) is True\n    assert q.poll() == 21\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_003", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_3():\n    q = BackpressureQueue(5)\n    assert q.offer(31) is True\n    assert q.offer(32) is True\n    assert q.offer(33) is True\n    assert q.poll() == 31\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_004", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_4():\n    q = BackpressureQueue(6)\n    assert q.offer(41) is True\n    assert q.offer(42) is True\n    assert q.offer(43) is True\n    assert q.poll() == 41\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_005", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_5():\n    q = BackpressureQueue(2)\n    assert q.offer(51) is True\n    assert q.offer(52) is True\n    assert q.offer(53) is False\n    assert q.poll() == 51\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_006", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_6():\n    q = BackpressureQueue(3)\n    assert q.offer(61) is True\n    assert q.offer(62) is True\n    assert q.offer(63) is True\n    assert q.poll() == 61\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_007", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_7():\n    q = BackpressureQueue(4)\n    assert q.offer(71) is True\n    assert q.offer(72) is True\n    assert q.offer(73) is True\n    assert q.poll() == 71\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_008", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_8():\n    q = BackpressureQueue(5)\n    assert q.offer(81) is True\n    assert q.offer(82) is True\n    assert q.offer(83) is True\n    assert q.poll() == 81\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_009", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_9():\n    q = BackpressureQueue(6)\n    assert q.offer(91) is True\n    assert q.offer(92) is True\n    assert q.offer(93) is True\n    assert q.poll() == 91\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_backpressure_010", "prompt": "Fix this bounded queue so it enforces capacity and preserves FIFO order.", "signature": "class BackpressureQueue:", "starter_code": "class BackpressureQueue:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.items = []\n        self.count = 0\n\n    def offer(self, item) -> bool:\n        if len(self.items) > self.capacity:\n            return False\n        self.items.append(item)\n        self.count += 1\n        return True\n\n    def poll(self):\n        if not self.items:\n            return None\n        self.count -= 1\n        return self.items.pop(0)\n", "tests": "def test_backpressure_queue_10():\n    q = BackpressureQueue(2)\n    assert q.offer(101) is True\n    assert q.offer(102) is True\n    assert q.offer(103) is False\n    assert q.poll() == 101\n", "category": "bugfix", "topic": "backpressure", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore", "counter", "deque", "circular_buffer"]}
{"task_id": "v10_osc_barrier_001", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_1():\n    b = SimpleBarrier(3)\n    for _ in range(3 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_002", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_2():\n    b = SimpleBarrier(4)\n    for _ in range(4 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_003", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_3():\n    b = SimpleBarrier(5)\n    for _ in range(5 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_004", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_4():\n    b = SimpleBarrier(2)\n    for _ in range(2 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_005", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_5():\n    b = SimpleBarrier(3)\n    for _ in range(3 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_006", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_6():\n    b = SimpleBarrier(4)\n    for _ in range(4 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_007", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_7():\n    b = SimpleBarrier(5)\n    for _ in range(5 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_008", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_8():\n    b = SimpleBarrier(2)\n    for _ in range(2 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_009", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_9():\n    b = SimpleBarrier(3)\n    for _ in range(3 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_barrier_010", "prompt": "Fix this barrier so it releases exactly when the required number of parties arrive.", "signature": "class SimpleBarrier:", "starter_code": "class SimpleBarrier:\n    def __init__(self, parties: int):\n        self.parties = parties\n        self.count = 0\n\n    def wait(self) -> bool:\n        self.count += 1\n        if self.count > self.parties:\n            self.count = 0\n            return True\n        return False\n", "tests": "def test_simple_barrier_10():\n    b = SimpleBarrier(4)\n    for _ in range(4 - 1):\n        assert b.wait() is False\n    assert b.wait() is True\n", "category": "bugfix", "topic": "barrier", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_barrier", "condition_notify", "event_counter", "generation_counter"]}
{"task_id": "v10_osc_tree_001", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_1():\n    tree = BST()\n    for v in [3, 2, 4]:\n        tree.insert(v)\n    for v in [3, 2, 4]:\n        assert tree.contains(v) is True\n    assert tree.contains(5) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_002", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_2():\n    tree = BST()\n    for v in [6, 5, 7]:\n        tree.insert(v)\n    for v in [6, 5, 7]:\n        assert tree.contains(v) is True\n    assert tree.contains(8) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_003", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_3():\n    tree = BST()\n    for v in [9, 8, 10]:\n        tree.insert(v)\n    for v in [9, 8, 10]:\n        assert tree.contains(v) is True\n    assert tree.contains(11) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_004", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_4():\n    tree = BST()\n    for v in [12, 11, 13]:\n        tree.insert(v)\n    for v in [12, 11, 13]:\n        assert tree.contains(v) is True\n    assert tree.contains(14) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_005", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_5():\n    tree = BST()\n    for v in [15, 14, 16]:\n        tree.insert(v)\n    for v in [15, 14, 16]:\n        assert tree.contains(v) is True\n    assert tree.contains(17) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_006", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_6():\n    tree = BST()\n    for v in [18, 17, 19]:\n        tree.insert(v)\n    for v in [18, 17, 19]:\n        assert tree.contains(v) is True\n    assert tree.contains(20) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_007", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_7():\n    tree = BST()\n    for v in [21, 20, 22]:\n        tree.insert(v)\n    for v in [21, 20, 22]:\n        assert tree.contains(v) is True\n    assert tree.contains(23) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_008", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_8():\n    tree = BST()\n    for v in [24, 23, 25]:\n        tree.insert(v)\n    for v in [24, 23, 25]:\n        assert tree.contains(v) is True\n    assert tree.contains(26) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_009", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_9():\n    tree = BST()\n    for v in [27, 26, 28]:\n        tree.insert(v)\n    for v in [27, 26, 28]:\n        assert tree.contains(v) is True\n    assert tree.contains(29) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_tree_010", "prompt": "Fix BST insertion so searches find inserted values.", "signature": "class BST:", "starter_code": "class Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int):\n        if self.root is None:\n            self.root = Node(value)\n            return\n        node = self.root\n        while True:\n            if value < node.value:\n                if node.right is None:\n                    node.right = Node(value)\n                    return\n                node = node.right\n            elif value > node.value:\n                if node.left is None:\n                    node.left = Node(value)\n                    return\n                node = node.left\n            else:\n                return\n\n    def contains(self, value: int) -> bool:\n        node = self.root\n        while node:\n            if value == node.value:\n                return True\n            if value < node.value:\n                node = node.left\n            else:\n                node = node.right\n        return False\n", "tests": "def test_bst_10():\n    tree = BST()\n    for v in [30, 29, 31]:\n        tree.insert(v)\n    for v in [30, 29, 31]:\n        assert tree.contains(v) is True\n    assert tree.contains(32) is False\n", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "iterative", "recursive"]}
{"task_id": "v10_osc_caching_001", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_1():\n    cache = FIFOCache(3)\n    cache.set('k1a', 1)\n    cache.set('k1b', 2)\n    cache.set('k1c', 3)\n    assert cache.get('k1a') is None\n    assert cache.get('k1b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_002", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_2():\n    cache = FIFOCache(4)\n    cache.set('k2a', 1)\n    cache.set('k2b', 2)\n    cache.set('k2c', 3)\n    assert cache.get('k2a') is None\n    assert cache.get('k2b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_003", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_3():\n    cache = FIFOCache(2)\n    cache.set('k3a', 1)\n    cache.set('k3b', 2)\n    cache.set('k3c', 3)\n    assert cache.get('k3a') is None\n    assert cache.get('k3b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_004", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_4():\n    cache = FIFOCache(3)\n    cache.set('k4a', 1)\n    cache.set('k4b', 2)\n    cache.set('k4c', 3)\n    assert cache.get('k4a') is None\n    assert cache.get('k4b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_005", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_5():\n    cache = FIFOCache(4)\n    cache.set('k5a', 1)\n    cache.set('k5b', 2)\n    cache.set('k5c', 3)\n    assert cache.get('k5a') is None\n    assert cache.get('k5b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_006", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_6():\n    cache = FIFOCache(2)\n    cache.set('k6a', 1)\n    cache.set('k6b', 2)\n    cache.set('k6c', 3)\n    assert cache.get('k6a') is None\n    assert cache.get('k6b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_007", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_7():\n    cache = FIFOCache(3)\n    cache.set('k7a', 1)\n    cache.set('k7b', 2)\n    cache.set('k7c', 3)\n    assert cache.get('k7a') is None\n    assert cache.get('k7b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_008", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_8():\n    cache = FIFOCache(4)\n    cache.set('k8a', 1)\n    cache.set('k8b', 2)\n    cache.set('k8c', 3)\n    assert cache.get('k8a') is None\n    assert cache.get('k8b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_009", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_9():\n    cache = FIFOCache(2)\n    cache.set('k9a', 1)\n    cache.set('k9b', 2)\n    cache.set('k9c', 3)\n    assert cache.get('k9a') is None\n    assert cache.get('k9b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_caching_010", "prompt": "Fix this cache so it evicts the oldest entry when capacity is exceeded (FIFO).", "signature": "class FIFOCache:", "starter_code": "class FIFOCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = {}\n        self.order = []\n\n    def get(self, key):\n        return self.data.get(key)\n\n    def set(self, key, value):\n        if key not in self.data:\n            self.order.append(key)\n        self.data[key] = value\n        if len(self.order) > self.capacity:\n            old = self.order.pop()\n            self.data.pop(old, None)\n", "tests": "def test_fifo_cache_10():\n    cache = FIFOCache(3)\n    cache.set('k10a', 1)\n    cache.set('k10b', 2)\n    cache.set('k10c', 3)\n    assert cache.get('k10a') is None\n    assert cache.get('k10b') == 2\n", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "functools", "lock_protected", "thread_local"]}
{"task_id": "v10_osc_circuit_breaker_001", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_1():\n    cb = CircuitBreaker(3)\n    for _ in range(3):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_002", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_2():\n    cb = CircuitBreaker(4)\n    for _ in range(4):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_003", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_3():\n    cb = CircuitBreaker(2)\n    for _ in range(2):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_004", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_4():\n    cb = CircuitBreaker(3)\n    for _ in range(3):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_005", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_5():\n    cb = CircuitBreaker(4)\n    for _ in range(4):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_006", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_6():\n    cb = CircuitBreaker(2)\n    for _ in range(2):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_007", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_7():\n    cb = CircuitBreaker(3)\n    for _ in range(3):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_008", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_8():\n    cb = CircuitBreaker(4)\n    for _ in range(4):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_009", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_9():\n    cb = CircuitBreaker(2)\n    for _ in range(2):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_circuit_breaker_010", "prompt": "Fix this circuit breaker so it opens when failures reach the threshold.", "signature": "class CircuitBreaker:", "starter_code": "class CircuitBreaker:\n    def __init__(self, threshold: int):\n        self.threshold = threshold\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def record_failure(self):\n        self.failures += 1\n        if self.failures > self.threshold:\n            self.state = \"OPEN\"\n\n    def record_success(self):\n        self.failures = 0\n        self.state = \"CLOSED\"\n\n    def allow_request(self) -> bool:\n        return self.state != \"OPEN\"\n", "tests": "def test_circuit_breaker_10():\n    cb = CircuitBreaker(3)\n    for _ in range(3):\n        cb.record_failure()\n    assert cb.allow_request() is False\n", "category": "bugfix", "topic": "circuit_breaker", "tier": "oscillation", "starter_check": "fail", "approaches": ["state_machine", "counter_threshold", "time_based", "sliding_window"]}
{"task_id": "v10_osc_connection_pool_001", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_1():\n    pool = ConnectionPool(3)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_002", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_2():\n    pool = ConnectionPool(4)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_003", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_3():\n    pool = ConnectionPool(5)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_004", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_4():\n    pool = ConnectionPool(2)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_005", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_5():\n    pool = ConnectionPool(3)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_006", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_6():\n    pool = ConnectionPool(4)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_007", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_7():\n    pool = ConnectionPool(5)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_008", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_8():\n    pool = ConnectionPool(2)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_009", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_9():\n    pool = ConnectionPool(3)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_connection_pool_010", "prompt": "Fix the connection pool so released connections are reusable.", "signature": "class ConnectionPool:", "starter_code": "class ConnectionPool:\n    def __init__(self, max_size: int):\n        self.max_size = max_size\n        self.pool = list(range(max_size))\n\n    def acquire(self):\n        if not self.pool:\n            return None\n        return self.pool.pop(0)\n\n    def release(self, conn):\n        if len(self.pool) > self.max_size:\n            self.pool.append(conn)\n", "tests": "def test_connection_pool_10():\n    pool = ConnectionPool(4)\n    c1 = pool.acquire()\n    assert c1 is not None\n    pool.release(c1)\n    c2 = pool.acquire()\n    assert c2 == c1\n", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_blocking", "semaphore", "list_with_lock"]}
{"task_id": "v10_osc_graph_001", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_1():\n    graph = {'A1': ['B1', 'C1'], 'B1': ['E1'], 'C1': ['D1'], 'D1': ['E1'], 'E1': []}\n    assert shortest_path_length(graph, 'A1', 'E1') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_002", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_2():\n    graph = {'A2': ['B2', 'C2'], 'B2': ['E2'], 'C2': ['D2'], 'D2': ['E2'], 'E2': []}\n    assert shortest_path_length(graph, 'A2', 'E2') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_003", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_3():\n    graph = {'A3': ['B3', 'C3'], 'B3': ['E3'], 'C3': ['D3'], 'D3': ['E3'], 'E3': []}\n    assert shortest_path_length(graph, 'A3', 'E3') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_004", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_4():\n    graph = {'A4': ['B4', 'C4'], 'B4': ['E4'], 'C4': ['D4'], 'D4': ['E4'], 'E4': []}\n    assert shortest_path_length(graph, 'A4', 'E4') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_005", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_5():\n    graph = {'A5': ['B5', 'C5'], 'B5': ['E5'], 'C5': ['D5'], 'D5': ['E5'], 'E5': []}\n    assert shortest_path_length(graph, 'A5', 'E5') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_006", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_6():\n    graph = {'A6': ['B6', 'C6'], 'B6': ['E6'], 'C6': ['D6'], 'D6': ['E6'], 'E6': []}\n    assert shortest_path_length(graph, 'A6', 'E6') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_007", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_7():\n    graph = {'A7': ['B7', 'C7'], 'B7': ['E7'], 'C7': ['D7'], 'D7': ['E7'], 'E7': []}\n    assert shortest_path_length(graph, 'A7', 'E7') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_008", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_8():\n    graph = {'A8': ['B8', 'C8'], 'B8': ['E8'], 'C8': ['D8'], 'D8': ['E8'], 'E8': []}\n    assert shortest_path_length(graph, 'A8', 'E8') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_009", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_9():\n    graph = {'A9': ['B9', 'C9'], 'B9': ['E9'], 'C9': ['D9'], 'D9': ['E9'], 'E9': []}\n    assert shortest_path_length(graph, 'A9', 'E9') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_graph_010", "prompt": "Return the shortest path length in an unweighted graph.", "signature": "def shortest_path_length(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_length(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_length_10():\n    graph = {'A10': ['B10', 'C10'], 'B10': ['E10'], 'C10': ['D10'], 'D10': ['E10'], 'E10': []}\n    assert shortest_path_length(graph, 'A10', 'E10') == 2\n", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list", "adjacency_matrix", "edge_set", "hybrid"]}
{"task_id": "v10_osc_heap_001", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_1():\n    h = MinHeap()\n    for v in [3, 5, 4]:\n        h.push(v)\n    assert h.pop() == 3\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_002", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_2():\n    h = MinHeap()\n    for v in [6, 8, 7]:\n        h.push(v)\n    assert h.pop() == 6\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_003", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_3():\n    h = MinHeap()\n    for v in [9, 11, 10]:\n        h.push(v)\n    assert h.pop() == 9\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_004", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_4():\n    h = MinHeap()\n    for v in [12, 14, 13]:\n        h.push(v)\n    assert h.pop() == 12\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_005", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_5():\n    h = MinHeap()\n    for v in [15, 17, 16]:\n        h.push(v)\n    assert h.pop() == 15\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_006", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_6():\n    h = MinHeap()\n    for v in [18, 20, 19]:\n        h.push(v)\n    assert h.pop() == 18\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_007", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_7():\n    h = MinHeap()\n    for v in [21, 23, 22]:\n        h.push(v)\n    assert h.pop() == 21\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_008", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_8():\n    h = MinHeap()\n    for v in [24, 26, 25]:\n        h.push(v)\n    assert h.pop() == 24\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_009", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_9():\n    h = MinHeap()\n    for v in [27, 29, 28]:\n        h.push(v)\n    assert h.pop() == 27\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_heap_010", "prompt": "Fix this min-heap so pop returns the smallest element.", "signature": "class MinHeap:", "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value):\n        heapq.heappush(self.data, value)\n\n    def pop(self):\n        if not self.data:\n            return None\n        return self.data.pop(0)\n", "tests": "def test_min_heap_10():\n    h = MinHeap()\n    for v in [30, 32, 31]:\n        h.push(v)\n    assert h.pop() == 30\n", "category": "bugfix", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v10_osc_interval_merge_001", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_1():\n    assert merge_intervals([(4, 6), (1, 2), (2, 5)]) == [(1, 6)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_002", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_2():\n    assert merge_intervals([(5, 7), (2, 3), (3, 6)]) == [(2, 7)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_003", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_3():\n    assert merge_intervals([(6, 8), (3, 4), (4, 7)]) == [(3, 8)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_004", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_4():\n    assert merge_intervals([(7, 9), (4, 5), (5, 8)]) == [(4, 9)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_005", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_5():\n    assert merge_intervals([(8, 10), (5, 6), (6, 9)]) == [(5, 10)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_006", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_6():\n    assert merge_intervals([(9, 11), (6, 7), (7, 10)]) == [(6, 11)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_007", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_7():\n    assert merge_intervals([(10, 12), (7, 8), (8, 11)]) == [(7, 12)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_008", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_8():\n    assert merge_intervals([(11, 13), (8, 9), (9, 12)]) == [(8, 13)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_009", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_9():\n    assert merge_intervals([(12, 14), (9, 10), (10, 13)]) == [(9, 14)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_interval_merge_010", "prompt": "Merge overlapping intervals from unsorted input.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_10():\n    assert merge_intervals([(13, 15), (10, 11), (11, 14)]) == [(10, 15)]\n", "category": "bugfix", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v10_osc_rwlock_001", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_1():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_002", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_2():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_003", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_3():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_004", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_4():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_005", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_5():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_006", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_6():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_007", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_7():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_008", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_8():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_009", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_9():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_rwlock_010", "prompt": "Fix this read/write lock so writers are blocked when readers are active.", "signature": "class ReadWriteLock:", "starter_code": "from threading import Lock\n\nclass ReadWriteLock:\n    def __init__(self):\n        self.readers = 0\n        self.writer = False\n        self.lock = Lock()\n\n    def acquire_read(self) -> bool:\n        if self.writer:\n            return False\n        self.readers += 1\n        return True\n\n    def release_read(self) -> None:\n        if self.readers > 0:\n            self.readers -= 1\n\n    def acquire_write(self) -> bool:\n        if self.writer:\n            return False\n        self.writer = True\n        return True\n\n    def release_write(self) -> None:\n        self.writer = False\n", "tests": "def test_read_write_lock_10():\n    rw = ReadWriteLock()\n    assert rw.acquire_read() is True\n    assert rw.acquire_write() is False\n    rw.release_read()\n    assert rw.acquire_write() is True\n", "category": "bugfix", "topic": "read_write_lock", "tier": "oscillation", "starter_check": "fail", "approaches": ["condition_based", "single_lock_counter", "two_locks", "rlock_counter"]}
{"task_id": "v10_osc_request_coalescing_001", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_1():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key1', factory) == \"value\"\n    assert c.get_or_start('key1', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_002", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_2():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key2', factory) == \"value\"\n    assert c.get_or_start('key2', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_003", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_3():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key3', factory) == \"value\"\n    assert c.get_or_start('key3', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_004", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_4():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key4', factory) == \"value\"\n    assert c.get_or_start('key4', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_005", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_5():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key5', factory) == \"value\"\n    assert c.get_or_start('key5', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_006", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_6():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key6', factory) == \"value\"\n    assert c.get_or_start('key6', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_007", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_7():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key7', factory) == \"value\"\n    assert c.get_or_start('key7', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_008", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_8():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key8', factory) == \"value\"\n    assert c.get_or_start('key8', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_009", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_9():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key9', factory) == \"value\"\n    assert c.get_or_start('key9', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_request_coalescing_010", "prompt": "Fix request coalescing so repeated calls reuse the same in-flight result.", "signature": "class RequestCoalescer:", "starter_code": "class RequestCoalescer:\n    def __init__(self):\n        self.inflight = {}\n\n    def get_or_start(self, key, factory):\n        if key in self.inflight:\n            return self.inflight[key]\n        value = factory()\n        return value\n", "tests": "def test_request_coalescer_10():\n    calls = []\n    def factory():\n        calls.append(1)\n        return \"value\"\n    c = RequestCoalescer()\n    assert c.get_or_start('key10', factory) == \"value\"\n    assert c.get_or_start('key10', factory) == \"value\"\n    assert len(calls) == 1\n", "category": "bugfix", "topic": "request_coalescing", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_of_futures", "dict_of_events", "lock_per_key"]}
{"task_id": "v10_osc_retry_001", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_1():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 2:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 2) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_002", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_2():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 3:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 3) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_003", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_3():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 1:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 1) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_004", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_4():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 2:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 2) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_005", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_5():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 3:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 3) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_006", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_6():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 1:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 1) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_007", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_7():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 2:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 2) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_008", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_8():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 3:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 3) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_009", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_9():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 1:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 1) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_retry_010", "prompt": "Fix retry so it makes retries + 1 total attempts.", "signature": "def retry_call(fn, retries: int):", "starter_code": "def retry_call(fn, retries: int):\n    last_err = None\n    for _ in range(retries):\n        try:\n            return fn()\n        except Exception as e:\n            last_err = e\n    if last_err:\n        raise last_err\n", "tests": "def test_retry_call_10():\n    attempts = {\"count\": 0}\n    def flaky():\n        attempts[\"count\"] += 1\n        if attempts[\"count\"] <= 2:\n            raise ValueError(\"fail\")\n        return \"ok\"\n    assert retry_call(flaky, 2) == \"ok\"\n", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["fixed_delay", "exponential_backoff", "jitter"]}
{"task_id": "v10_osc_ring_001", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_1():\n    rb = RingBuffer(4)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_002", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_2():\n    rb = RingBuffer(5)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_003", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_3():\n    rb = RingBuffer(3)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_004", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_4():\n    rb = RingBuffer(4)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_005", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_5():\n    rb = RingBuffer(5)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_006", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_6():\n    rb = RingBuffer(3)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_007", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_7():\n    rb = RingBuffer(4)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_008", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_8():\n    rb = RingBuffer(5)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_009", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_9():\n    rb = RingBuffer(3)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_ring_010", "prompt": "Fix this ring buffer so it overwrites the oldest item when full.", "signature": "class RingBuffer:", "starter_code": "class RingBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = [None] * capacity\n        self.head = 0\n        self.size = 0\n\n    def append(self, item) -> None:\n        idx = (self.head + self.size) % self.capacity\n        self.data[idx] = item\n        if self.size < self.capacity:\n            self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        item = self.data[self.head]\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n", "tests": "def test_ring_buffer_10():\n    rb = RingBuffer(4)\n    rb.append(1)\n    rb.append(2)\n    rb.append(3)\n    rb.append(4)\n    assert rb.pop() == 2\n", "category": "bugfix", "topic": "ring_buffer", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque", "modulo_index", "list_rotate"]}
{"task_id": "v10_osc_semaphore_001", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_1():\n    s = SimpleSemaphore(3)\n    for _ in range(3):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 3\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_002", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_2():\n    s = SimpleSemaphore(4)\n    for _ in range(4):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 4\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_003", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_3():\n    s = SimpleSemaphore(5)\n    for _ in range(5):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 5\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_004", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_4():\n    s = SimpleSemaphore(2)\n    for _ in range(2):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 2\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_005", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_5():\n    s = SimpleSemaphore(3)\n    for _ in range(3):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 3\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_006", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_6():\n    s = SimpleSemaphore(4)\n    for _ in range(4):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 4\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_007", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_7():\n    s = SimpleSemaphore(5)\n    for _ in range(5):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 5\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_008", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_8():\n    s = SimpleSemaphore(2)\n    for _ in range(2):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 2\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_009", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_9():\n    s = SimpleSemaphore(3)\n    for _ in range(3):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 3\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_semaphore_010", "prompt": "Fix semaphore release so permits never exceed the maximum.", "signature": "class SimpleSemaphore:", "starter_code": "class SimpleSemaphore:\n    def __init__(self, permits: int):\n        self.max_permits = permits\n        self.permits = permits\n\n    def acquire(self) -> bool:\n        if self.permits <= 0:\n            return False\n        self.permits -= 1\n        return True\n\n    def release(self) -> None:\n        self.permits += 1\n", "tests": "def test_simple_semaphore_10():\n    s = SimpleSemaphore(4)\n    for _ in range(4):\n        assert s.acquire() is True\n    assert s.acquire() is False\n    s.release()\n    s.release()\n    count = 0\n    while s.acquire():\n        count += 1\n    assert count == 4\n", "category": "bugfix", "topic": "semaphore", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_semaphore", "counter_condition", "queue_tokens"]}
{"task_id": "v10_osc_skip_001", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_1():\n    sl = SkipList()\n    for v in [1, 3, 5]:\n        sl.insert(v)\n    assert sl.search(3) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_002", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_2():\n    sl = SkipList()\n    for v in [2, 4, 6]:\n        sl.insert(v)\n    assert sl.search(4) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_003", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_3():\n    sl = SkipList()\n    for v in [3, 5, 7]:\n        sl.insert(v)\n    assert sl.search(5) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_004", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_4():\n    sl = SkipList()\n    for v in [4, 6, 8]:\n        sl.insert(v)\n    assert sl.search(6) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_005", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_5():\n    sl = SkipList()\n    for v in [5, 7, 9]:\n        sl.insert(v)\n    assert sl.search(7) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_006", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_6():\n    sl = SkipList()\n    for v in [6, 8, 10]:\n        sl.insert(v)\n    assert sl.search(8) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_007", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_7():\n    sl = SkipList()\n    for v in [7, 9, 11]:\n        sl.insert(v)\n    assert sl.search(9) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_008", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_8():\n    sl = SkipList()\n    for v in [8, 10, 12]:\n        sl.insert(v)\n    assert sl.search(10) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_009", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_9():\n    sl = SkipList()\n    for v in [9, 11, 13]:\n        sl.insert(v)\n    assert sl.search(11) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_skip_010", "prompt": "Fix this simplified skip list so search checks lower levels.", "signature": "class SkipList:", "starter_code": "class SkipList:\n    def __init__(self):\n        self.level0 = []\n        self.level1 = []\n\n    def insert(self, value: int):\n        if value not in self.level0:\n            self.level0.append(value)\n            self.level0.sort()\n            if len(self.level0) % 2 == 0:\n                self.level1.append(value)\n                self.level1.sort()\n\n    def search(self, value: int) -> bool:\n        return value in self.level1\n", "tests": "def test_skip_list_10():\n    sl = SkipList()\n    for v in [10, 12, 14]:\n        sl.insert(v)\n    assert sl.search(12) is True\n", "category": "bugfix", "topic": "skip_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_levels", "array_levels", "sorted_list_baseline"]}
{"task_id": "v10_osc_string_match_001", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_1():\n    assert find_substring('abcde1xyz', 'xyz') == 6\n    assert find_substring('abcde1xyz', 'nope1') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_002", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_2():\n    assert find_substring('abcde2xyz', 'xyz') == 6\n    assert find_substring('abcde2xyz', 'nope2') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_003", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_3():\n    assert find_substring('abcde3xyz', 'xyz') == 6\n    assert find_substring('abcde3xyz', 'nope3') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_004", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_4():\n    assert find_substring('abcde4xyz', 'xyz') == 6\n    assert find_substring('abcde4xyz', 'nope4') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_005", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_5():\n    assert find_substring('abcde5xyz', 'xyz') == 6\n    assert find_substring('abcde5xyz', 'nope5') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_006", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_6():\n    assert find_substring('abcde6xyz', 'xyz') == 6\n    assert find_substring('abcde6xyz', 'nope6') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_007", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_7():\n    assert find_substring('abcde7xyz', 'xyz') == 6\n    assert find_substring('abcde7xyz', 'nope7') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_008", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_8():\n    assert find_substring('abcde8xyz', 'xyz') == 6\n    assert find_substring('abcde8xyz', 'nope8') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_009", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_9():\n    assert find_substring('abcde9xyz', 'xyz') == 6\n    assert find_substring('abcde9xyz', 'nope9') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_string_match_010", "prompt": "Find the first index of pattern in text or -1 if not found.", "signature": "def find_substring(text: str, pattern: str) -> int:", "starter_code": "def find_substring(text: str, pattern: str) -> int:\n    idx = text.find(pattern)\n    if idx == -1:\n        return 0\n    return idx\n", "tests": "def test_find_substring_10():\n    assert find_substring('abcde10xyz', 'xyz') == 7\n    assert find_substring('abcde10xyz', 'nope10') == -1\n", "category": "bugfix", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v10_osc_thread_pool_001", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_1():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_002", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_2():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_003", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_3():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_004", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_4():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_005", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_5():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_006", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_6():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_007", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_7():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_008", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_8():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_009", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_9():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_thread_pool_010", "prompt": "Fix this thread pool simulation so tasks run FIFO order.", "signature": "class ThreadPool:", "starter_code": "class ThreadPool:\n    def __init__(self):\n        self.queue = []\n\n    def submit(self, fn, *args):\n        self.queue.append((fn, args))\n\n    def run_all(self):\n        results = []\n        while self.queue:\n            fn, args = self.queue.pop()\n            results.append(fn(*args))\n        return results\n", "tests": "def test_thread_pool_10():\n    pool = ThreadPool()\n    pool.submit(lambda x: x + 1, 1)\n    pool.submit(lambda x: x + 1, 2)\n    pool.submit(lambda x: x + 1, 3)\n    assert pool.run_all() == [2, 3, 4]\n", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["futures", "queue_workers", "dynamic_threads"]}
{"task_id": "v10_osc_timer_001", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_1():\n    t = ManualTimer(6)\n    t.tick(6)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_002", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_2():\n    t = ManualTimer(7)\n    t.tick(7)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_003", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_3():\n    t = ManualTimer(5)\n    t.tick(5)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_004", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_4():\n    t = ManualTimer(6)\n    t.tick(6)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_005", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_5():\n    t = ManualTimer(7)\n    t.tick(7)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_006", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_6():\n    t = ManualTimer(5)\n    t.tick(5)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_007", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_7():\n    t = ManualTimer(6)\n    t.tick(6)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_008", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_8():\n    t = ManualTimer(7)\n    t.tick(7)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_009", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_9():\n    t = ManualTimer(5)\n    t.tick(5)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_timer_010", "prompt": "Fix this timer so it expires when elapsed >= interval.", "signature": "class ManualTimer:", "starter_code": "class ManualTimer:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.elapsed = 0\n\n    def tick(self, delta_ms: int):\n        self.elapsed += delta_ms\n\n    def expired(self) -> bool:\n        return self.elapsed > self.interval_ms\n", "tests": "def test_manual_timer_10():\n    t = ManualTimer(6)\n    t.tick(6)\n    assert t.expired() is True\n", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_flag", "loop_thread"]}
{"task_id": "v10_osc_topological_sort_001", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_1():\n    graph = {'A1': ['B1'], 'B1': ['C1']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A1', 'B1', 'C1'])\n    assert len(order) == len(['A1', 'B1', 'C1'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_002", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_2():\n    graph = {'A2': ['B2'], 'B2': ['C2']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A2', 'B2', 'C2'])\n    assert len(order) == len(['A2', 'B2', 'C2'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_003", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_3():\n    graph = {'A3': ['B3'], 'B3': ['C3']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A3', 'B3', 'C3'])\n    assert len(order) == len(['A3', 'B3', 'C3'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_004", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_4():\n    graph = {'A4': ['B4'], 'B4': ['C4']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A4', 'B4', 'C4'])\n    assert len(order) == len(['A4', 'B4', 'C4'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_005", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_5():\n    graph = {'A5': ['B5'], 'B5': ['C5']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A5', 'B5', 'C5'])\n    assert len(order) == len(['A5', 'B5', 'C5'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_006", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_6():\n    graph = {'A6': ['B6'], 'B6': ['C6']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A6', 'B6', 'C6'])\n    assert len(order) == len(['A6', 'B6', 'C6'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_007", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_7():\n    graph = {'A7': ['B7'], 'B7': ['C7']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A7', 'B7', 'C7'])\n    assert len(order) == len(['A7', 'B7', 'C7'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_008", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_8():\n    graph = {'A8': ['B8'], 'B8': ['C8']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A8', 'B8', 'C8'])\n    assert len(order) == len(['A8', 'B8', 'C8'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_009", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_9():\n    graph = {'A9': ['B9'], 'B9': ['C9']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A9', 'B9', 'C9'])\n    assert len(order) == len(['A9', 'B9', 'C9'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_topological_sort_010", "prompt": "Return a topological ordering that includes all nodes.", "signature": "def topological_sort(graph: dict) -> list:", "starter_code": "def topological_sort(graph: dict) -> list:\n    indegree = {node: 0 for node in graph}\n    for node, nbrs in graph.items():\n        for nbr in nbrs:\n            indegree[nbr] = indegree.get(nbr, 0) + 1\n    queue = [n for n in graph if indegree.get(n, 0) == 0]\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for nbr in graph.get(node, []):\n            indegree[nbr] -= 1\n            if indegree[nbr] == 0:\n                queue.append(nbr)\n    return order\n", "tests": "def test_topological_sort_10():\n    graph = {'A10': ['B10'], 'B10': ['C10']}\n    order = topological_sort(graph)\n    assert set(order) == set(['A10', 'B10', 'C10'])\n    assert len(order) == len(['A10', 'B10', 'C10'])\n", "category": "bugfix", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v10_osc_trie_001", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_1():\n    trie = Trie()\n    trie.insert('word1')\n    assert trie.search('word1') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_002", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_2():\n    trie = Trie()\n    trie.insert('word2')\n    assert trie.search('word2') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_003", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_3():\n    trie = Trie()\n    trie.insert('word3')\n    assert trie.search('word3') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_004", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_4():\n    trie = Trie()\n    trie.insert('word4')\n    assert trie.search('word4') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_005", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_5():\n    trie = Trie()\n    trie.insert('word5')\n    assert trie.search('word5') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_006", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_6():\n    trie = Trie()\n    trie.insert('word6')\n    assert trie.search('word6') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_007", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_7():\n    trie = Trie()\n    trie.insert('word7')\n    assert trie.search('word7') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_008", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_8():\n    trie = Trie()\n    trie.insert('word8')\n    assert trie.search('word8') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_009", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_9():\n    trie = Trie()\n    trie.insert('word9')\n    assert trie.search('word9') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v10_osc_trie_010", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_10():\n    trie = Trie()\n    trie.insert('word10')\n    assert trie.search('word10') is True\n    assert trie.search('wor') is False\n", "category": "bugfix", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
