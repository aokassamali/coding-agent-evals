{"task_id": "v9_t1_between_01", "prompt": "Fix this function so it returns True when x is between low and high inclusive.", "signature": "def is_between(x: int, low: int, high: int) -> bool:", "starter_code": "def is_between(x: int, low: int, high: int) -> bool:\n    return low < x < high\n", "tests": "def test_is_between_1():\n    assert is_between(1, 1, 3) is True\n    assert is_between(2, 1, 3) is True\n    assert is_between(3, 1, 3) is True\n    assert is_between(0, 1, 3) is False\n    assert is_between(4, 1, 3) is False\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_between_02", "prompt": "Fix this function so it returns True when x is between low and high inclusive.", "signature": "def is_between(x: int, low: int, high: int) -> bool:", "starter_code": "def is_between(x: int, low: int, high: int) -> bool:\n    return low < x < high\n", "tests": "def test_is_between_2():\n    assert is_between(0, 0, 10) is True\n    assert is_between(5, 0, 10) is True\n    assert is_between(10, 0, 10) is True\n    assert is_between(-1, 0, 10) is False\n    assert is_between(11, 0, 10) is False\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_between_03", "prompt": "Fix this function so it returns True when x is between low and high inclusive.", "signature": "def is_between(x: int, low: int, high: int) -> bool:", "starter_code": "def is_between(x: int, low: int, high: int) -> bool:\n    return low < x < high\n", "tests": "def test_is_between_3():\n    assert is_between(-5, -5, 5) is True\n    assert is_between(0, -5, 5) is True\n    assert is_between(5, -5, 5) is True\n    assert is_between(-6, -5, 5) is False\n    assert is_between(6, -5, 5) is False\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_between_04", "prompt": "Fix this function so it returns True when x is between low and high inclusive.", "signature": "def is_between(x: int, low: int, high: int) -> bool:", "starter_code": "def is_between(x: int, low: int, high: int) -> bool:\n    return low < x < high\n", "tests": "def test_is_between_4():\n    assert is_between(2, 2, 4) is True\n    assert is_between(3, 2, 4) is True\n    assert is_between(4, 2, 4) is True\n    assert is_between(1, 2, 4) is False\n    assert is_between(5, 2, 4) is False\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_between_05", "prompt": "Fix this function so it returns True when x is between low and high inclusive.", "signature": "def is_between(x: int, low: int, high: int) -> bool:", "starter_code": "def is_between(x: int, low: int, high: int) -> bool:\n    return low < x < high\n", "tests": "def test_is_between_5():\n    assert is_between(10, 10, 20) is True\n    assert is_between(15, 10, 20) is True\n    assert is_between(20, 10, 20) is True\n    assert is_between(9, 10, 20) is False\n    assert is_between(21, 10, 20) is False\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_safe_div_01", "prompt": "Fix this function to return None when dividing by zero.", "signature": "def safe_divide(a: float, b: float):", "starter_code": "def safe_divide(a: float, b: float):\n    if b == 0:\n        return 0\n    return a / b\n", "tests": "def test_safe_divide_1():\n    assert safe_divide(10, 2) == 5.0\n    assert safe_divide(10, 0) is None\n", "category": "bugfix", "topic": "math", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_safe_div_02", "prompt": "Fix this function to return None when dividing by zero.", "signature": "def safe_divide(a: float, b: float):", "starter_code": "def safe_divide(a: float, b: float):\n    if b == 0:\n        return 0\n    return a / b\n", "tests": "def test_safe_divide_2():\n    assert safe_divide(7, -2) == -3.5\n    assert safe_divide(7, 0) is None\n", "category": "bugfix", "topic": "math", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_safe_div_03", "prompt": "Fix this function to return None when dividing by zero.", "signature": "def safe_divide(a: float, b: float):", "starter_code": "def safe_divide(a: float, b: float):\n    if b == 0:\n        return 0\n    return a / b\n", "tests": "def test_safe_divide_3():\n    assert safe_divide(-9, 3) == -3.0\n    assert safe_divide(-9, 0) is None\n", "category": "bugfix", "topic": "math", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_safe_div_04", "prompt": "Fix this function to return None when dividing by zero.", "signature": "def safe_divide(a: float, b: float):", "starter_code": "def safe_divide(a: float, b: float):\n    if b == 0:\n        return 0\n    return a / b\n", "tests": "def test_safe_divide_4():\n    assert safe_divide(5, 4) == 1.25\n    assert safe_divide(5, 0) is None\n", "category": "bugfix", "topic": "math", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_safe_div_05", "prompt": "Fix this function to return None when dividing by zero.", "signature": "def safe_divide(a: float, b: float):", "starter_code": "def safe_divide(a: float, b: float):\n    if b == 0:\n        return 0\n    return a / b\n", "tests": "def test_safe_divide_5():\n    assert safe_divide(0, 5) == 0.0\n    assert safe_divide(0, 0) is None\n", "category": "bugfix", "topic": "math", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_last_char_01", "prompt": "Return the last character of s, or '' if s is empty.", "signature": "def last_char(s: str) -> str:", "starter_code": "def last_char(s: str) -> str:\n    return s[-1]\n", "tests": "def test_last_char_1():\n    assert last_char('alpha') == 'a'\n    assert last_char(\"\") == \"\"\n", "category": "bugfix", "topic": "strings", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_last_char_02", "prompt": "Return the last character of s, or '' if s is empty.", "signature": "def last_char(s: str) -> str:", "starter_code": "def last_char(s: str) -> str:\n    return s[-1]\n", "tests": "def test_last_char_2():\n    assert last_char('Z') == 'Z'\n    assert last_char(\"\") == \"\"\n", "category": "bugfix", "topic": "strings", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_last_char_03", "prompt": "Return the last character of s, or '' if s is empty.", "signature": "def last_char(s: str) -> str:", "starter_code": "def last_char(s: str) -> str:\n    return s[-1]\n", "tests": "def test_last_char_3():\n    assert last_char('hello') == 'o'\n    assert last_char(\"\") == \"\"\n", "category": "bugfix", "topic": "strings", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_last_char_04", "prompt": "Return the last character of s, or '' if s is empty.", "signature": "def last_char(s: str) -> str:", "starter_code": "def last_char(s: str) -> str:\n    return s[-1]\n", "tests": "def test_last_char_4():\n    assert last_char('12345') == '5'\n    assert last_char(\"\") == \"\"\n", "category": "bugfix", "topic": "strings", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_last_char_05", "prompt": "Return the last character of s, or '' if s is empty.", "signature": "def last_char(s: str) -> str:", "starter_code": "def last_char(s: str) -> str:\n    return s[-1]\n", "tests": "def test_last_char_5():\n    assert last_char('mixEd') == 'd'\n    assert last_char(\"\") == \"\"\n", "category": "bugfix", "topic": "strings", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_clamp_01", "prompt": "Clamp x to the inclusive range [low, high].", "signature": "def clamp_value(x: int, low: int, high: int) -> int:", "starter_code": "def clamp_value(x: int, low: int, high: int) -> int:\n    if x < low:\n        return high\n    if x > high:\n        return low\n    return x\n", "tests": "def test_clamp_value_1():\n    assert clamp_value(5, 0, 10) == 5\n    assert clamp_value(-1, 0, 10) == 0\n    assert clamp_value(11, 0, 10) == 10\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_clamp_02", "prompt": "Clamp x to the inclusive range [low, high].", "signature": "def clamp_value(x: int, low: int, high: int) -> int:", "starter_code": "def clamp_value(x: int, low: int, high: int) -> int:\n    if x < low:\n        return high\n    if x > high:\n        return low\n    return x\n", "tests": "def test_clamp_value_2():\n    assert clamp_value(0, -3, 3) == 0\n    assert clamp_value(-4, -3, 3) == -3\n    assert clamp_value(4, -3, 3) == 3\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_clamp_03", "prompt": "Clamp x to the inclusive range [low, high].", "signature": "def clamp_value(x: int, low: int, high: int) -> int:", "starter_code": "def clamp_value(x: int, low: int, high: int) -> int:\n    if x < low:\n        return high\n    if x > high:\n        return low\n    return x\n", "tests": "def test_clamp_value_3():\n    assert clamp_value(2, 1, 4) == 2\n    assert clamp_value(0, 1, 4) == 1\n    assert clamp_value(5, 1, 4) == 4\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_clamp_04", "prompt": "Clamp x to the inclusive range [low, high].", "signature": "def clamp_value(x: int, low: int, high: int) -> int:", "starter_code": "def clamp_value(x: int, low: int, high: int) -> int:\n    if x < low:\n        return high\n    if x > high:\n        return low\n    return x\n", "tests": "def test_clamp_value_4():\n    assert clamp_value(15, 10, 20) == 15\n    assert clamp_value(9, 10, 20) == 10\n    assert clamp_value(21, 10, 20) == 20\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t1_clamp_05", "prompt": "Clamp x to the inclusive range [low, high].", "signature": "def clamp_value(x: int, low: int, high: int) -> int:", "starter_code": "def clamp_value(x: int, low: int, high: int) -> int:\n    if x < low:\n        return high\n    if x > high:\n        return low\n    return x\n", "tests": "def test_clamp_value_5():\n    assert clamp_value(-5, -10, -1) == -5\n    assert clamp_value(-11, -10, -1) == -10\n    assert clamp_value(0, -10, -1) == -1\n", "category": "bugfix", "topic": "conditionals", "tier": 1, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_01", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_1():\n    assert count_occurrences([1, 2, 1, 1, 3], 1) == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_02", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_2():\n    assert count_occurrences(['a', 'b', 'a', 'c', 'a'], 'a') == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_03", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_3():\n    assert count_occurrences([5, 5, 5, 2, 5], 5) == 4\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_04", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_4():\n    assert count_occurrences([0, 1, 0, 2, 0, 3], 0) == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_05", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_5():\n    assert count_occurrences(['x', 'y', 'z', 'y'], 'y') == 2\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_06", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_6():\n    assert count_occurrences([3, 4, 3, 4, 3, 4], 4) == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_07", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_7():\n    assert count_occurrences(['cat', 'dog', 'cat'], 'cat') == 2\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_08", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_8():\n    assert count_occurrences([9, 8, 7, 8, 8], 8) == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_09", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_9():\n    assert count_occurrences(['p', 'q', 'p', 'q', 'p'], 'p') == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_count_occ_10", "prompt": "Return how many times target appears in items.", "signature": "def count_occurrences(items: list, target) -> int:", "starter_code": "def count_occurrences(items: list, target) -> int:\n    count = 0\n    for item in items:\n        if item == target:\n            count = 1\n    return count\n", "tests": "def test_count_occurrences_10():\n    assert count_occurrences([True, False, True, True], True) == 3\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_01", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_1():\n    assert rotate_right([0, 1, 2, 3, 4, 5], 1) == [5, 0, 1, 2, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_02", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_2():\n    assert rotate_right([1, 2, 3, 4, 5, 6], 2) == [5, 6, 1, 2, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_03", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_3():\n    assert rotate_right([2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 2, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_04", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_4():\n    assert rotate_right([3, 4, 5, 6, 7, 8], 4) == [5, 6, 7, 8, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_05", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_5():\n    assert rotate_right([4, 5, 6, 7, 8, 9], 5) == [5, 6, 7, 8, 9, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_06", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_6():\n    assert rotate_right([5, 6, 7, 8, 9, 10], 6) == [5, 6, 7, 8, 9, 10]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_07", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_7():\n    assert rotate_right([6, 7, 8, 9, 10, 11], 7) == [11, 6, 7, 8, 9, 10]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_08", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_8():\n    assert rotate_right([7, 8, 9, 10, 11, 12], 8) == [11, 12, 7, 8, 9, 10]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_09", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_9():\n    assert rotate_right([8, 9, 10, 11, 12, 13], 9) == [11, 12, 13, 8, 9, 10]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_rotate_10", "prompt": "Rotate items to the right by k (k may be larger than the list length).", "signature": "def rotate_right(items: list, k: int) -> list:", "starter_code": "def rotate_right(items: list, k: int) -> list:\n    if not items:\n        return []\n    return items[-k:] + items[:-k]\n", "tests": "def test_rotate_right_10():\n    assert rotate_right([9, 10, 11, 12, 13, 14], 10) == [11, 12, 13, 14, 9, 10]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_01", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_1():\n    assert dedupe_preserve_order([1, 2, 1, 3, 2, 4]) == [1, 2, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_02", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_2():\n    assert dedupe_preserve_order(['a', 'b', 'a', 'c', 'b']) == ['a', 'b', 'c']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_03", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_3():\n    assert dedupe_preserve_order([5, 5, 5, 1, 2]) == [5, 1, 2]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_04", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_4():\n    assert dedupe_preserve_order(['x', 'x', 'y', 'x']) == ['x', 'y']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_05", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_5():\n    assert dedupe_preserve_order([True, False, True, True, False]) == [True, False]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_06", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_6():\n    assert dedupe_preserve_order(['cat', 'dog', 'cat', 'bird']) == ['cat', 'dog', 'bird']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_07", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_7():\n    assert dedupe_preserve_order([9, 8, 9, 7, 8]) == [9, 8, 7]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_08", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_8():\n    assert dedupe_preserve_order(['p', 'q', 'p', 'q', 'r']) == ['p', 'q', 'r']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_09", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_9():\n    assert dedupe_preserve_order([0, 1, 0, 2, 0]) == [0, 1, 2]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_dedupe_10", "prompt": "Remove duplicates while preserving original order.", "signature": "def dedupe_preserve_order(items: list) -> list:", "starter_code": "def dedupe_preserve_order(items: list) -> list:\n    return list(set(items))\n", "tests": "def test_dedupe_preserve_order_10():\n    assert dedupe_preserve_order(['aa', 'aa', 'bb', 'aa']) == ['aa', 'bb']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_01", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_1():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8], 2) == [[1, 2], [3, 4], [5, 6], [7, 8]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_02", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_2():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_03", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_3():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) == [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_04", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_4():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 2) == [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_05", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_5():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 3) == [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_06", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_6():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 4) == [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_07", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_7():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 2) == [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_08", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_8():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 3) == [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_09", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_9():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 4) == [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_chunk_10", "prompt": "Split items into chunks of size N (final chunk may be shorter).", "signature": "def chunk_list(items: list, size: int) -> list:", "starter_code": "def chunk_list(items: list, size: int) -> list:\n    chunks = []\n    for i in range(0, len(items) - size, size):\n        chunks.append(items[i:i + size])\n    return chunks\n", "tests": "def test_chunk_list_10():\n    assert chunk_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 2) == [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16], [17]]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_01", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_1():\n    assert flatten_once([1, [2, 3], 4]) == [1, 2, 3, 4]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_02", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_2():\n    assert flatten_once([[1, 2], 3, [4, 5]]) == [1, 2, 3, 4, 5]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_03", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_3():\n    assert flatten_once(['a', ['b', 'c'], 'd']) == ['a', 'b', 'c', 'd']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_04", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_4():\n    assert flatten_once([[], [1], 2]) == [1, 2]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_05", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_5():\n    assert flatten_once([[1], [2], [3]]) == [1, 2, 3]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_06", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_6():\n    assert flatten_once([1, 2, [3, 4, 5]]) == [1, 2, 3, 4, 5]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_07", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_7():\n    assert flatten_once(['x', ['y'], ['z']]) == ['x', 'y', 'z']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_08", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_8():\n    assert flatten_once([[1, 2], [3], 4, [5, 6]]) == [1, 2, 3, 4, 5, 6]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_09", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_9():\n    assert flatten_once([[], 'a', ['b']]) == ['a', 'b']\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t2_flatten_10", "prompt": "Flatten one nesting level of lists.", "signature": "def flatten_once(items: list) -> list:", "starter_code": "def flatten_once(items: list) -> list:\n    out = []\n    for x in items:\n        if isinstance(x, list):\n            out.append(x)\n        else:\n            out.append(x)\n    return out\n", "tests": "def test_flatten_once_10():\n    assert flatten_once([[0], 1, 2]) == [0, 1, 2]\n", "category": "bugfix", "topic": "lists", "tier": 2, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_01", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_1():\n    assert merge_intervals([(5, 7), (1, 3), (2, 4)]) == [(1, 4), (5, 7)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_02", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_2():\n    assert merge_intervals([(6, 8), (1, 2), (3, 5)]) == [(1, 2), (3, 5), (6, 8)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_03", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_3():\n    assert merge_intervals([(1, 4), (0, 0), (5, 7), (2, 3)]) == [(0, 0), (1, 4), (5, 7)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_04", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_4():\n    assert merge_intervals([(10, 12), (2, 4), (3, 8)]) == [(2, 8), (10, 12)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_05", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_5():\n    assert merge_intervals([(1, 2), (2, 6), (8, 10), (9, 11)]) == [(1, 6), (8, 11)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_06", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_6():\n    assert merge_intervals([(3, 5), (1, 2), (6, 7)]) == [(1, 2), (3, 5), (6, 7)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_07", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_7():\n    assert merge_intervals([(4, 5), (1, 10), (2, 3)]) == [(1, 10)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_08", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_8():\n    assert merge_intervals([(0, 1), (1, 2), (2, 3)]) == [(0, 3)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_09", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_9():\n    assert merge_intervals([(7, 9), (2, 6), (1, 3)]) == [(1, 6), (7, 9)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_merge_intervals_10", "prompt": "Merge overlapping intervals. Input may be unsorted.", "signature": "def merge_intervals(intervals: list) -> list:", "starter_code": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n", "tests": "def test_merge_intervals_10():\n    assert merge_intervals([(15, 18), (1, 2), (2, 4)]) == [(1, 4), (15, 18)]\n", "category": "bugfix", "topic": "intervals", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_01", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_1():\n    result = group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_02", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_2():\n    result = group_anagrams(['listen', 'silent', 'enlist', 'google'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['enlist', 'listen', 'silent'], ['google']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_03", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_3():\n    result = group_anagrams(['rat', 'tar', 'art', 'car'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['art', 'rat', 'tar'], ['car']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_04", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_4():\n    result = group_anagrams(['abc', 'bca', 'cab', 'xyz'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['abc', 'bca', 'cab'], ['xyz']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_05", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_5():\n    result = group_anagrams(['a', 'b', 'a'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['a', 'a'], ['b']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_06", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_6():\n    result = group_anagrams(['dusty', 'study', 'night', 'thing'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['dusty', 'study'], ['night', 'thing']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_07", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_7():\n    result = group_anagrams(['evil', 'vile', 'veil', 'live'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['evil', 'live', 'veil', 'vile']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_08", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_8():\n    result = group_anagrams(['loop', 'polo', 'pool', 'lopo'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['loop', 'lopo', 'polo', 'pool']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_09", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_9():\n    result = group_anagrams(['state', 'taste', 'tates'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['state', 'taste', 'tates']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_group_anagrams_10", "prompt": "Group words that are anagrams of each other.", "signature": "def group_anagrams(words: list) -> list:", "starter_code": "def group_anagrams(words: list) -> list:\n    groups = {}\n    for w in words:\n        key = w\n        groups.setdefault(key, []).append(w)\n    return list(groups.values())\n", "tests": "def test_group_anagrams_10():\n    result = group_anagrams(['one', 'neo', 'eon', 'two'])\n    normalized = sorted([sorted(g) for g in result], key=lambda g: g[0])\n    assert normalized == [['eon', 'neo', 'one'], ['two']]\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_01", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_1():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_02", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_2():\n    assert top_k_frequent(['a', 'b', 'a', 'c', 'b', 'a'], 1) == ['a']\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_03", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_3():\n    assert top_k_frequent([4, 4, 5, 6, 6, 6], 2) == [6, 4]\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_04", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_4():\n    assert top_k_frequent(['x', 'y', 'x', 'z', 'z', 'z'], 2) == ['z', 'x']\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_05", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_5():\n    assert top_k_frequent([9, 9, 8, 7, 7, 7, 8], 1) == [7]\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_06", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_6():\n    assert top_k_frequent(['cat', 'dog', 'cat', 'bird', 'dog', 'cat'], 2) == ['cat', 'dog']\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_07", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_7():\n    assert top_k_frequent([10, 11, 10, 12, 12, 12, 11], 3) == [12, 10, 11]\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_08", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_8():\n    assert top_k_frequent(['p', 'q', 'p', 'r', 'p', 'q'], 2) == ['p', 'q']\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_09", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_9():\n    assert top_k_frequent([0, 0, 0, 1, 2, 2], 2) == [0, 2]\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_topk_10", "prompt": "Return the k most frequent items.", "signature": "def top_k_frequent(items: list, k: int) -> list:", "starter_code": "def top_k_frequent(items: list, k: int) -> list:\n    freq = {}\n    for x in items:\n        freq[x] = freq.get(x, 0) + 1\n    ordered = sorted(freq.items(), key=lambda kv: kv[1])\n    return [x for x, _ in ordered[:k]]\n", "tests": "def test_top_k_frequent_10():\n    assert top_k_frequent(['aa', 'bb', 'aa', 'cc', 'bb', 'bb'], 2) == ['bb', 'aa']\n", "category": "bugfix", "topic": "frequency", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_01", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_1():\n    assert is_balanced('([]){}') is True\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_02", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_2():\n    assert is_balanced('([)]') is False\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_03", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_3():\n    assert is_balanced('{[()]}') is True\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_04", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_4():\n    assert is_balanced('((()))') is True\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_05", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_5():\n    assert is_balanced('([{}])') is True\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_06", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_6():\n    assert is_balanced('(]') is False\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_07", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_7():\n    assert is_balanced('(()') is False\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_08", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_8():\n    assert is_balanced('())') is False\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_09", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_9():\n    assert is_balanced('{[}]') is False\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_brackets_10", "prompt": "Return True if the brackets are balanced for (), [], {}.", "signature": "def is_balanced(s: str) -> bool:", "starter_code": "def is_balanced(s: str) -> bool:\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for ch in s:\n        if ch in pairs.values():\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "tests": "def test_is_balanced_10():\n    assert is_balanced('[]{}()') is True\n", "category": "bugfix", "topic": "stack", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_01", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_1():\n    assert normalize_path('/a/b/../c') == '/a/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_02", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_2():\n    assert normalize_path('/a/./b/./c') == '/a/b/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_03", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_3():\n    assert normalize_path('/../a/b') == '/a/b'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_04", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_4():\n    assert normalize_path('/a/b/c/..') == '/a/b'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_05", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_5():\n    assert normalize_path('/a//b///c') == '/a/b/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_06", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_6():\n    assert normalize_path('/a/b/../../d') == '/d'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_07", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_7():\n    assert normalize_path('/x/y/z/../..') == '/x'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_08", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_8():\n    assert normalize_path('/a/../b/../c') == '/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_09", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_9():\n    assert normalize_path('/a/b/././c') == '/a/b/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_norm_path_10", "prompt": "Normalize a Unix-style path by resolving '.' and '..'.", "signature": "def normalize_path(path: str) -> str:", "starter_code": "def normalize_path(path: str) -> str:\n    parts = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            continue\n        parts.append(part)\n    return '/' + '/'.join(parts)\n", "tests": "def test_normalize_path_10():\n    assert normalize_path('/a/b/c') == '/a/b/c'\n", "category": "bugfix", "topic": "parsing", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_01", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_1():\n    assert rle_encode('aaabbc') == 'a3b2c1'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_02", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_2():\n    assert rle_encode('abcd') == 'a1b1c1d1'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_03", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_3():\n    assert rle_encode('aabbaa') == 'a2b2a2'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_04", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_4():\n    assert rle_encode('zzzz') == 'z4'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_05", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_5():\n    assert rle_encode('a') == 'a1'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_06", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_6():\n    assert rle_encode('abccccc') == 'a1b1c5'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_07", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_7():\n    assert rle_encode('wwwwx') == 'w4x1'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_08", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_8():\n    assert rle_encode('ppqqq') == 'p2q3'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_09", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_9():\n    assert rle_encode('mmmmnn') == 'm4n2'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t3_rle_10", "prompt": "Run-length encode the string (e.g., 'aaab' -> 'a3b1').", "signature": "def rle_encode(s: str) -> str:", "starter_code": "def rle_encode(s: str) -> str:\n    if not s:\n        return \"\"\n    out = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            out.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    return \"\".join(out)\n", "tests": "def test_rle_encode_10():\n    assert rle_encode('yyyz') == 'y3z1'\n", "category": "bugfix", "topic": "strings", "tier": 3, "starter_check": "fail"}
{"task_id": "v9_t4_lru_01", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_1():\n    cache = LRUCache(2)\n    for k, v in [('a', 1), ('b', 2), ('c', 3)][:2]:\n        cache.put(k, v)\n    assert cache.get('a') == 1\n    cache.put('c', 3)\n    assert cache.get('b') is None\n    assert cache.get('a') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_02", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_2():\n    cache = LRUCache(2)\n    for k, v in [('x', 1), ('y', 2), ('z', 3)][:2]:\n        cache.put(k, v)\n    assert cache.get('x') == 1\n    cache.put('z', 3)\n    assert cache.get('y') is None\n    assert cache.get('x') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_03", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_3():\n    cache = LRUCache(3)\n    for k, v in [('k1', 1), ('k2', 2), ('k3', 3), ('k4', 4)][:2]:\n        cache.put(k, v)\n    assert cache.get('k1') == 1\n    cache.put('k3', 3)\n    assert cache.get('k2') is None\n    assert cache.get('k1') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_04", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_4():\n    cache = LRUCache(2)\n    for k, v in [('p', 7), ('q', 8), ('r', 9)][:2]:\n        cache.put(k, v)\n    assert cache.get('p') == 7\n    cache.put('r', 9)\n    assert cache.get('q') is None\n    assert cache.get('p') == 7\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_05", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_5():\n    cache = LRUCache(3)\n    for k, v in [('u', 1), ('v', 2), ('w', 3), ('t', 4)][:2]:\n        cache.put(k, v)\n    assert cache.get('u') == 1\n    cache.put('w', 3)\n    assert cache.get('v') is None\n    assert cache.get('u') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_06", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_6():\n    cache = LRUCache(2)\n    for k, v in [('m', 1), ('n', 2), ('o', 3)][:2]:\n        cache.put(k, v)\n    assert cache.get('m') == 1\n    cache.put('o', 3)\n    assert cache.get('n') is None\n    assert cache.get('m') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_07", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_7():\n    cache = LRUCache(3)\n    for k, v in [('aa', 1), ('bb', 2), ('cc', 3), ('dd', 4)][:2]:\n        cache.put(k, v)\n    assert cache.get('aa') == 1\n    cache.put('cc', 3)\n    assert cache.get('bb') is None\n    assert cache.get('aa') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_08", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_8():\n    cache = LRUCache(2)\n    for k, v in [('s', 1), ('t', 2), ('u', 3)][:2]:\n        cache.put(k, v)\n    assert cache.get('s') == 1\n    cache.put('u', 3)\n    assert cache.get('t') is None\n    assert cache.get('s') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_09", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_9():\n    cache = LRUCache(3)\n    for k, v in [('h', 5), ('i', 6), ('j', 7), ('k', 8)][:2]:\n        cache.put(k, v)\n    assert cache.get('h') == 5\n    cache.put('j', 7)\n    assert cache.get('i') is None\n    assert cache.get('h') == 5\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_lru_10", "prompt": "Fix this LRU cache so recent gets update the eviction order.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key):\n        if key not in self.data:\n            return None\n        return self.data[key]\n\n    def put(self, key, value):\n        if key in self.data:\n            self.data[key] = value\n            return\n        self.data[key] = value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)\n", "tests": "def test_lru_cache_10():\n    cache = LRUCache(2)\n    for k, v in [('r1', 1), ('r2', 2), ('r3', 3)][:2]:\n        cache.put(k, v)\n    assert cache.get('r1') == 1\n    cache.put('r3', 3)\n    assert cache.get('r2') is None\n    assert cache.get('r1') == 1\n", "category": "bugfix", "topic": "caching", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_01", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_1():\n    trie = Trie()\n    trie.insert('cat')\n    assert trie.search('cat') is True\n    assert trie.search('car') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_02", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_2():\n    trie = Trie()\n    trie.insert('apple')\n    assert trie.search('apple') is True\n    assert trie.search('app') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_03", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_3():\n    trie = Trie()\n    trie.insert('dog')\n    assert trie.search('dog') is True\n    assert trie.search('do') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_04", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_4():\n    trie = Trie()\n    trie.insert('tree')\n    assert trie.search('tree') is True\n    assert trie.search('tr') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_05", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_5():\n    trie = Trie()\n    trie.insert('house')\n    assert trie.search('house') is True\n    assert trie.search('hou') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_06", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_6():\n    trie = Trie()\n    trie.insert('train')\n    assert trie.search('train') is True\n    assert trie.search('tra') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_07", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_7():\n    trie = Trie()\n    trie.insert('plane')\n    assert trie.search('plane') is True\n    assert trie.search('pla') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_08", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_8():\n    trie = Trie()\n    trie.insert('note')\n    assert trie.search('note') is True\n    assert trie.search('no') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_09", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_9():\n    trie = Trie()\n    trie.insert('ring')\n    assert trie.search('ring') is True\n    assert trie.search('ri') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_trie_10", "prompt": "Fix this Trie so search returns True only for whole words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_10():\n    trie = Trie()\n    trie.insert('road')\n    assert trie.search('road') is True\n    assert trie.search('ro') is False\n", "category": "bugfix", "topic": "trie", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_01", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_1():\n    uf = UnionFind([1, 2, 3])\n    for a, b in [(1, 2), (2, 3)]:\n        uf.union(a, b)\n    assert uf.find(1) == uf.find(3)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_02", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_2():\n    uf = UnionFind([4, 5, 6])\n    for a, b in [(4, 5), (5, 6)]:\n        uf.union(a, b)\n    assert uf.find(4) == uf.find(6)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_03", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_3():\n    uf = UnionFind([10, 11, 12])\n    for a, b in [(10, 11), (11, 12)]:\n        uf.union(a, b)\n    assert uf.find(10) == uf.find(12)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_04", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_4():\n    uf = UnionFind([7, 8, 9])\n    for a, b in [(7, 8), (8, 9)]:\n        uf.union(a, b)\n    assert uf.find(7) == uf.find(9)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_05", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_5():\n    uf = UnionFind([20, 21, 22])\n    for a, b in [(20, 21), (21, 22)]:\n        uf.union(a, b)\n    assert uf.find(20) == uf.find(22)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_06", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_6():\n    uf = UnionFind([30, 31, 32])\n    for a, b in [(30, 31), (31, 32)]:\n        uf.union(a, b)\n    assert uf.find(30) == uf.find(32)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_07", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_7():\n    uf = UnionFind([40, 41, 42])\n    for a, b in [(40, 41), (41, 42)]:\n        uf.union(a, b)\n    assert uf.find(40) == uf.find(42)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_08", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_8():\n    uf = UnionFind([50, 51, 52])\n    for a, b in [(50, 51), (51, 52)]:\n        uf.union(a, b)\n    assert uf.find(50) == uf.find(52)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_09", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_9():\n    uf = UnionFind([60, 61, 62])\n    for a, b in [(60, 61), (61, 62)]:\n        uf.union(a, b)\n    assert uf.find(60) == uf.find(62)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_union_find_10", "prompt": "Fix UnionFind so find returns the true root for chained unions.", "signature": "class UnionFind:", "starter_code": "class UnionFind:\n    def __init__(self, items):\n        self.parent = {x: x for x in items}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[rb] = ra\n", "tests": "def test_union_find_10():\n    uf = UnionFind([70, 71, 72])\n    for a, b in [(70, 71), (71, 72)]:\n        uf.union(a, b)\n    assert uf.find(70) == uf.find(72)\n", "category": "bugfix", "topic": "disjoint_set", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_01", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_1():\n    graph = {'S0': ['M0', 'L0'], 'M0': ['E0'], 'L0': ['L0b'], 'L0b': ['E0'], 'E0': []}\n    assert shortest_path_len(graph, 'S0', 'E0') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_02", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_2():\n    graph = {'S1': ['M1', 'L1'], 'M1': ['E1'], 'L1': ['L1b'], 'L1b': ['E1'], 'E1': []}\n    assert shortest_path_len(graph, 'S1', 'E1') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_03", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_3():\n    graph = {'S2': ['M2', 'L2'], 'M2': ['E2'], 'L2': ['L2b'], 'L2b': ['E2'], 'E2': []}\n    assert shortest_path_len(graph, 'S2', 'E2') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_04", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_4():\n    graph = {'S3': ['M3', 'L3'], 'M3': ['E3'], 'L3': ['L3b'], 'L3b': ['E3'], 'E3': []}\n    assert shortest_path_len(graph, 'S3', 'E3') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_05", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_5():\n    graph = {'S4': ['M4', 'L4'], 'M4': ['E4'], 'L4': ['L4b'], 'L4b': ['E4'], 'E4': []}\n    assert shortest_path_len(graph, 'S4', 'E4') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_06", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_6():\n    graph = {'S5': ['M5', 'L5'], 'M5': ['E5'], 'L5': ['L5b'], 'L5b': ['E5'], 'E5': []}\n    assert shortest_path_len(graph, 'S5', 'E5') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_07", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_7():\n    graph = {'S6': ['M6', 'L6'], 'M6': ['E6'], 'L6': ['L6b'], 'L6b': ['E6'], 'E6': []}\n    assert shortest_path_len(graph, 'S6', 'E6') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_08", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_8():\n    graph = {'S7': ['M7', 'L7'], 'M7': ['E7'], 'L7': ['L7b'], 'L7b': ['E7'], 'E7': []}\n    assert shortest_path_len(graph, 'S7', 'E7') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_09", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_9():\n    graph = {'S8': ['M8', 'L8'], 'M8': ['E8'], 'L8': ['L8b'], 'L8b': ['E8'], 'E8': []}\n    assert shortest_path_len(graph, 'S8', 'E8') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_shortest_path_10", "prompt": "Return the length of the shortest path in an unweighted graph.", "signature": "def shortest_path_len(graph: dict, start, end) -> int:", "starter_code": "def shortest_path_len(graph: dict, start, end) -> int:\n    stack = [(start, 0)]\n    visited = set()\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node in visited:\n            continue\n        visited.add(node)\n        for nbr in graph.get(node, []):\n            stack.append((nbr, dist + 1))\n    return -1\n", "tests": "def test_shortest_path_len_10():\n    graph = {'S9': ['M9', 'L9'], 'M9': ['E9'], 'L9': ['L9b'], 'L9b': ['E9'], 'E9': []}\n    assert shortest_path_len(graph, 'S9', 'E9') == 2\n", "category": "bugfix", "topic": "graph", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_01", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_1():\n    rl = RateLimiter(5)\n    assert rl.allow(0) is True\n    assert rl.allow(5) is True\n    assert rl.allow(5) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_02", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_2():\n    rl = RateLimiter(3)\n    assert rl.allow(0) is True\n    assert rl.allow(3) is True\n    assert rl.allow(3) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_03", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_3():\n    rl = RateLimiter(7)\n    assert rl.allow(0) is True\n    assert rl.allow(7) is True\n    assert rl.allow(7) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_04", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_4():\n    rl = RateLimiter(2)\n    assert rl.allow(0) is True\n    assert rl.allow(2) is True\n    assert rl.allow(2) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_05", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_5():\n    rl = RateLimiter(4)\n    assert rl.allow(0) is True\n    assert rl.allow(4) is True\n    assert rl.allow(4) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_06", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_6():\n    rl = RateLimiter(6)\n    assert rl.allow(0) is True\n    assert rl.allow(6) is True\n    assert rl.allow(6) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_07", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_7():\n    rl = RateLimiter(8)\n    assert rl.allow(0) is True\n    assert rl.allow(8) is True\n    assert rl.allow(8) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_08", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_8():\n    rl = RateLimiter(9)\n    assert rl.allow(0) is True\n    assert rl.allow(9) is True\n    assert rl.allow(9) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_09", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_9():\n    rl = RateLimiter(10)\n    assert rl.allow(0) is True\n    assert rl.allow(10) is True\n    assert rl.allow(10) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t4_rate_limit_10", "prompt": "Allow calls only if at least interval_ms has elapsed since the last allowed call.", "signature": "class RateLimiter:", "starter_code": "class RateLimiter:\n    def __init__(self, interval_ms: int):\n        self.interval_ms = interval_ms\n        self.last_ms = None\n\n    def allow(self, now_ms: int) -> bool:\n        if self.last_ms is None:\n            self.last_ms = now_ms\n            return True\n        if now_ms - self.last_ms > self.interval_ms:\n            self.last_ms = now_ms\n            return True\n        return False\n", "tests": "def test_rate_limiter_10():\n    rl = RateLimiter(12)\n    assert rl.allow(0) is True\n    assert rl.allow(12) is True\n    assert rl.allow(12) is False\n", "category": "bugfix", "topic": "rate_limiting", "tier": 4, "starter_check": "fail"}
{"task_id": "v9_t5_descriptor_01", "prompt": "Fix this descriptor so values are stored per instance (not shared).", "signature": "class PositiveInt:", "starter_code": "class PositiveInt:\n    def __init__(self, name: str):\n        self.name = name\n        self.value = None\n\n    def __get__(self, obj, objtype=None):\n        return self.value\n\n    def __set__(self, obj, value: int):\n        if value < 0:\n            raise ValueError(\"must be non-negative\")\n        self.value = value\n\nclass Account:\n    balance = PositiveInt(\"balance\")\n\n    def __init__(self, balance: int):\n        self.balance = balance\n", "tests": "def test_descriptor_1():\n    a = Account(1)\n    b = Account(2)\n    assert a.balance == 1\n    assert b.balance == 2\n", "category": "bugfix", "topic": "descriptors", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_descriptor_02", "prompt": "Fix this descriptor so values are stored per instance (not shared).", "signature": "class PositiveInt:", "starter_code": "class PositiveInt:\n    def __init__(self, name: str):\n        self.name = name\n        self.value = None\n\n    def __get__(self, obj, objtype=None):\n        return self.value\n\n    def __set__(self, obj, value: int):\n        if value < 0:\n            raise ValueError(\"must be non-negative\")\n        self.value = value\n\nclass Account:\n    score = PositiveInt(\"score\")\n\n    def __init__(self, score: int):\n        self.score = score\n", "tests": "def test_descriptor_2():\n    a = Account(1)\n    b = Account(2)\n    assert a.score == 1\n    assert b.score == 2\n", "category": "bugfix", "topic": "descriptors", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_descriptor_03", "prompt": "Fix this descriptor so values are stored per instance (not shared).", "signature": "class PositiveInt:", "starter_code": "class PositiveInt:\n    def __init__(self, name: str):\n        self.name = name\n        self.value = None\n\n    def __get__(self, obj, objtype=None):\n        return self.value\n\n    def __set__(self, obj, value: int):\n        if value < 0:\n            raise ValueError(\"must be non-negative\")\n        self.value = value\n\nclass Account:\n    level = PositiveInt(\"level\")\n\n    def __init__(self, level: int):\n        self.level = level\n", "tests": "def test_descriptor_3():\n    a = Account(1)\n    b = Account(2)\n    assert a.level == 1\n    assert b.level == 2\n", "category": "bugfix", "topic": "descriptors", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_descriptor_04", "prompt": "Fix this descriptor so values are stored per instance (not shared).", "signature": "class PositiveInt:", "starter_code": "class PositiveInt:\n    def __init__(self, name: str):\n        self.name = name\n        self.value = None\n\n    def __get__(self, obj, objtype=None):\n        return self.value\n\n    def __set__(self, obj, value: int):\n        if value < 0:\n            raise ValueError(\"must be non-negative\")\n        self.value = value\n\nclass Account:\n    quota = PositiveInt(\"quota\")\n\n    def __init__(self, quota: int):\n        self.quota = quota\n", "tests": "def test_descriptor_4():\n    a = Account(1)\n    b = Account(2)\n    assert a.quota == 1\n    assert b.quota == 2\n", "category": "bugfix", "topic": "descriptors", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_descriptor_05", "prompt": "Fix this descriptor so values are stored per instance (not shared).", "signature": "class PositiveInt:", "starter_code": "class PositiveInt:\n    def __init__(self, name: str):\n        self.name = name\n        self.value = None\n\n    def __get__(self, obj, objtype=None):\n        return self.value\n\n    def __set__(self, obj, value: int):\n        if value < 0:\n            raise ValueError(\"must be non-negative\")\n        self.value = value\n\nclass Account:\n    limit = PositiveInt(\"limit\")\n\n    def __init__(self, limit: int):\n        self.limit = limit\n", "tests": "def test_descriptor_5():\n    a = Account(1)\n    b = Account(2)\n    assert a.limit == 1\n    assert b.limit == 2\n", "category": "bugfix", "topic": "descriptors", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_context_01", "prompt": "Fix this context manager so it restores the previous flag value on exit.", "signature": "class ToggleFlag:", "starter_code": "class ToggleFlag:\n    def __init__(self, obj, attr: str):\n        self.obj = obj\n        self.attr = attr\n        self.prev = None\n\n    def __enter__(self):\n        self.prev = getattr(self.obj, self.attr)\n        setattr(self.obj, self.attr, True)\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        pass\n\nclass Box:\n    def __init__(self):\n        self.enabled = False\n", "tests": "def test_toggle_flag_1():\n    box = Box()\n    assert box.enabled is False\n    with ToggleFlag(box, \"enabled\"):\n        assert box.enabled is True\n    assert box.enabled is False\n", "category": "bugfix", "topic": "context_manager", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_context_02", "prompt": "Fix this context manager so it restores the previous flag value on exit.", "signature": "class ToggleFlag:", "starter_code": "class ToggleFlag:\n    def __init__(self, obj, attr: str):\n        self.obj = obj\n        self.attr = attr\n        self.prev = None\n\n    def __enter__(self):\n        self.prev = getattr(self.obj, self.attr)\n        setattr(self.obj, self.attr, True)\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        pass\n\nclass Box:\n    def __init__(self):\n        self.active = False\n", "tests": "def test_toggle_flag_2():\n    box = Box()\n    assert box.active is False\n    with ToggleFlag(box, \"active\"):\n        assert box.active is True\n    assert box.active is False\n", "category": "bugfix", "topic": "context_manager", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_context_03", "prompt": "Fix this context manager so it restores the previous flag value on exit.", "signature": "class ToggleFlag:", "starter_code": "class ToggleFlag:\n    def __init__(self, obj, attr: str):\n        self.obj = obj\n        self.attr = attr\n        self.prev = None\n\n    def __enter__(self):\n        self.prev = getattr(self.obj, self.attr)\n        setattr(self.obj, self.attr, True)\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        pass\n\nclass Box:\n    def __init__(self):\n        self.flag = False\n", "tests": "def test_toggle_flag_3():\n    box = Box()\n    assert box.flag is False\n    with ToggleFlag(box, \"flag\"):\n        assert box.flag is True\n    assert box.flag is False\n", "category": "bugfix", "topic": "context_manager", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_context_04", "prompt": "Fix this context manager so it restores the previous flag value on exit.", "signature": "class ToggleFlag:", "starter_code": "class ToggleFlag:\n    def __init__(self, obj, attr: str):\n        self.obj = obj\n        self.attr = attr\n        self.prev = None\n\n    def __enter__(self):\n        self.prev = getattr(self.obj, self.attr)\n        setattr(self.obj, self.attr, True)\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        pass\n\nclass Box:\n    def __init__(self):\n        self.visible = False\n", "tests": "def test_toggle_flag_4():\n    box = Box()\n    assert box.visible is False\n    with ToggleFlag(box, \"visible\"):\n        assert box.visible is True\n    assert box.visible is False\n", "category": "bugfix", "topic": "context_manager", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_context_05", "prompt": "Fix this context manager so it restores the previous flag value on exit.", "signature": "class ToggleFlag:", "starter_code": "class ToggleFlag:\n    def __init__(self, obj, attr: str):\n        self.obj = obj\n        self.attr = attr\n        self.prev = None\n\n    def __enter__(self):\n        self.prev = getattr(self.obj, self.attr)\n        setattr(self.obj, self.attr, True)\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        pass\n\nclass Box:\n    def __init__(self):\n        self.ready = False\n", "tests": "def test_toggle_flag_5():\n    box = Box()\n    assert box.ready is False\n    with ToggleFlag(box, \"ready\"):\n        assert box.ready is True\n    assert box.ready is False\n", "category": "bugfix", "topic": "context_manager", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_iter_01", "prompt": "Fix this iterator so it yields values from start up to end (exclusive).", "signature": "class RangeIter:", "starter_code": "class RangeIter:\n    def __init__(self, start: int, end: int):\n        self.cur = start\n        self.end = end\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.cur > self.end:\n            raise StopIteration\n        val = self.cur\n        self.cur += 1\n        return val\n", "tests": "def test_range_iter_1():\n    it = RangeIter(0, 3)\n    assert list(it) == list(range(0, 3))\n", "category": "bugfix", "topic": "iterators", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_iter_02", "prompt": "Fix this iterator so it yields values from start up to end (exclusive).", "signature": "class RangeIter:", "starter_code": "class RangeIter:\n    def __init__(self, start: int, end: int):\n        self.cur = start\n        self.end = end\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.cur > self.end:\n            raise StopIteration\n        val = self.cur\n        self.cur += 1\n        return val\n", "tests": "def test_range_iter_2():\n    it = RangeIter(1, 5)\n    assert list(it) == list(range(1, 5))\n", "category": "bugfix", "topic": "iterators", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_iter_03", "prompt": "Fix this iterator so it yields values from start up to end (exclusive).", "signature": "class RangeIter:", "starter_code": "class RangeIter:\n    def __init__(self, start: int, end: int):\n        self.cur = start\n        self.end = end\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.cur > self.end:\n            raise StopIteration\n        val = self.cur\n        self.cur += 1\n        return val\n", "tests": "def test_range_iter_3():\n    it = RangeIter(2, 6)\n    assert list(it) == list(range(2, 6))\n", "category": "bugfix", "topic": "iterators", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_iter_04", "prompt": "Fix this iterator so it yields values from start up to end (exclusive).", "signature": "class RangeIter:", "starter_code": "class RangeIter:\n    def __init__(self, start: int, end: int):\n        self.cur = start\n        self.end = end\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.cur > self.end:\n            raise StopIteration\n        val = self.cur\n        self.cur += 1\n        return val\n", "tests": "def test_range_iter_4():\n    it = RangeIter(5, 9)\n    assert list(it) == list(range(5, 9))\n", "category": "bugfix", "topic": "iterators", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_iter_05", "prompt": "Fix this iterator so it yields values from start up to end (exclusive).", "signature": "class RangeIter:", "starter_code": "class RangeIter:\n    def __init__(self, start: int, end: int):\n        self.cur = start\n        self.end = end\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.cur > self.end:\n            raise StopIteration\n        val = self.cur\n        self.cur += 1\n        return val\n", "tests": "def test_range_iter_5():\n    it = RangeIter(10, 13)\n    assert list(it) == list(range(10, 13))\n", "category": "bugfix", "topic": "iterators", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_pickle_01", "prompt": "Fix __getstate__ so sensitive data is not stored in the pickle.", "signature": "class SecureNote:", "starter_code": "class SecureNote:\n    def __init__(self, user: str, secret: str):\n        self.user = user\n        self.secret = secret\n\n    def __getstate__(self):\n        return self.__dict__\n", "tests": "def test_secure_note_1():\n    import pickle\n    note = SecureNote('alice', 'secret1')\n    blob = pickle.dumps(note)\n    restored = pickle.loads(blob)\n    assert restored.user == 'alice'\n    assert restored.secret is None\n", "category": "bugfix", "topic": "pickle_protocol", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_pickle_02", "prompt": "Fix __getstate__ so sensitive data is not stored in the pickle.", "signature": "class SecureNote:", "starter_code": "class SecureNote:\n    def __init__(self, user: str, secret: str):\n        self.user = user\n        self.secret = secret\n\n    def __getstate__(self):\n        return self.__dict__\n", "tests": "def test_secure_note_2():\n    import pickle\n    note = SecureNote('bob', 'secret2')\n    blob = pickle.dumps(note)\n    restored = pickle.loads(blob)\n    assert restored.user == 'bob'\n    assert restored.secret is None\n", "category": "bugfix", "topic": "pickle_protocol", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_pickle_03", "prompt": "Fix __getstate__ so sensitive data is not stored in the pickle.", "signature": "class SecureNote:", "starter_code": "class SecureNote:\n    def __init__(self, user: str, secret: str):\n        self.user = user\n        self.secret = secret\n\n    def __getstate__(self):\n        return self.__dict__\n", "tests": "def test_secure_note_3():\n    import pickle\n    note = SecureNote('carol', 'secret3')\n    blob = pickle.dumps(note)\n    restored = pickle.loads(blob)\n    assert restored.user == 'carol'\n    assert restored.secret is None\n", "category": "bugfix", "topic": "pickle_protocol", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_pickle_04", "prompt": "Fix __getstate__ so sensitive data is not stored in the pickle.", "signature": "class SecureNote:", "starter_code": "class SecureNote:\n    def __init__(self, user: str, secret: str):\n        self.user = user\n        self.secret = secret\n\n    def __getstate__(self):\n        return self.__dict__\n", "tests": "def test_secure_note_4():\n    import pickle\n    note = SecureNote('dave', 'secret4')\n    blob = pickle.dumps(note)\n    restored = pickle.loads(blob)\n    assert restored.user == 'dave'\n    assert restored.secret is None\n", "category": "bugfix", "topic": "pickle_protocol", "tier": 5, "starter_check": "fail"}
{"task_id": "v9_t5_pickle_05", "prompt": "Fix __getstate__ so sensitive data is not stored in the pickle.", "signature": "class SecureNote:", "starter_code": "class SecureNote:\n    def __init__(self, user: str, secret: str):\n        self.user = user\n        self.secret = secret\n\n    def __getstate__(self):\n        return self.__dict__\n", "tests": "def test_secure_note_5():\n    import pickle\n    note = SecureNote('eve', 'secret5')\n    blob = pickle.dumps(note)\n    restored = pickle.loads(blob)\n    assert restored.user == 'eve'\n    assert restored.secret is None\n", "category": "bugfix", "topic": "pickle_protocol", "tier": 5, "starter_check": "fail"}
