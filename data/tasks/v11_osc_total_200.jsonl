{"task_id": "v11_osc_string_match_001", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_1():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_002", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_2():\n    assert find_all_indices('abababababa', 'aba') == [0, 2, 4, 6, 8]\n    assert find_all_indices('abababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_003", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_3():\n    assert find_all_indices('abcabcabcabcab', 'abc') == [0, 3, 6, 9]\n    assert find_all_indices('abcabcabcabcab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_004", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_4():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_005", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_5():\n    assert find_all_indices('aaabaaabaaabaaabaaab', 'aaab') == [0, 4, 8, 12, 16]\n    assert find_all_indices('aaabaaabaaabaaabaaab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_006", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_6():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_007", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_7():\n    assert find_all_indices('ababababa', 'aba') == [0, 2, 4, 6]\n    assert find_all_indices('ababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_008", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_8():\n    assert find_all_indices('abcabcabcab', 'abc') == [0, 3, 6]\n    assert find_all_indices('abcabcabcab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_009", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_9():\n    assert find_all_indices('mississippi', 'issi') == [1, 4]\n    assert find_all_indices('mississippi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_010", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_10():\n    assert find_all_indices('aaabaaabaaabaaab', 'aaab') == [0, 4, 8, 12]\n    assert find_all_indices('aaabaaabaaabaaab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_011", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_11():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_012", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_12():\n    assert find_all_indices('abababa', 'aba') == [0, 2, 4]\n    assert find_all_indices('abababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_013", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_13():\n    assert find_all_indices('abcabcabcabcab', 'abc') == [0, 3, 6, 9]\n    assert find_all_indices('abcabcabcabcab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_014", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_14():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_015", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_15():\n    assert find_all_indices('aaabaaabaaab', 'aaab') == [0, 4, 8]\n    assert find_all_indices('aaabaaabaaab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_016", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_16():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_017", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_17():\n    assert find_all_indices('abababababa', 'aba') == [0, 2, 4, 6, 8]\n    assert find_all_indices('abababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_018", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_18():\n    assert find_all_indices('abcabcabcab', 'abc') == [0, 3, 6]\n    assert find_all_indices('abcabcabcab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_019", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_19():\n    assert find_all_indices('mississippi', 'issi') == [1, 4]\n    assert find_all_indices('mississippi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_020", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_20():\n    assert find_all_indices('aaabaaabaaabaaabaaab', 'aaab') == [0, 4, 8, 12, 16]\n    assert find_all_indices('aaabaaabaaabaaabaaab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_021", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_21():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_022", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_22():\n    assert find_all_indices('ababababa', 'aba') == [0, 2, 4, 6]\n    assert find_all_indices('ababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_023", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_23():\n    assert find_all_indices('abcabcabcabcab', 'abc') == [0, 3, 6, 9]\n    assert find_all_indices('abcabcabcabcab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_024", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_24():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_025", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_25():\n    assert find_all_indices('aaabaaabaaabaaab', 'aaab') == [0, 4, 8, 12]\n    assert find_all_indices('aaabaaabaaabaaab', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_interval_merge_001", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_1():\n    assert merge_intervals([(3, 5), (4, 7), (9, 11), (11, 12)]) == [(3, 7), (9, 12)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_002", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_2():\n    assert merge_intervals([(3, 5), (14, 15), (12, 14), (7, 10), (6, 8)]) == [(3, 5), (6, 10), (12, 15)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_003", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_3():\n    assert merge_intervals([(9, 11), (10, 13), (15, 17), (17, 18), (13, 14)]) == [(9, 14), (15, 18)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_004", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_4():\n    assert merge_intervals([(9, 11), (20, 21), (18, 20), (13, 16), (12, 14)]) == [(9, 11), (12, 16), (18, 21)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_005", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_5():\n    assert merge_intervals([(15, 17), (16, 19), (21, 23), (23, 24)]) == [(15, 19), (21, 24)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_006", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_6():\n    assert merge_intervals([(22, 23), (15, 17), (26, 27), (24, 26), (19, 22), (18, 20)]) == [(15, 17), (18, 23), (24, 27)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_007", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_7():\n    assert merge_intervals([(21, 23), (22, 25), (27, 29), (29, 30)]) == [(21, 25), (27, 30)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_008", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_8():\n    assert merge_intervals([(21, 23), (32, 33), (30, 32), (25, 28), (24, 26)]) == [(21, 23), (24, 28), (30, 33)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_009", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_9():\n    assert merge_intervals([(27, 29), (28, 31), (33, 35), (35, 36), (31, 32)]) == [(27, 32), (33, 36)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_010", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_10():\n    assert merge_intervals([(27, 29), (38, 39), (36, 38), (31, 34), (30, 32)]) == [(27, 29), (30, 34), (36, 39)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_011", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_11():\n    assert merge_intervals([(33, 35), (34, 37), (39, 41), (41, 42)]) == [(33, 37), (39, 42)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_012", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_12():\n    assert merge_intervals([(40, 41), (33, 35), (44, 45), (42, 44), (37, 40), (36, 38)]) == [(33, 35), (36, 41), (42, 45)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_013", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_13():\n    assert merge_intervals([(39, 41), (40, 43), (45, 47), (47, 48)]) == [(39, 43), (45, 48)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_014", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_14():\n    assert merge_intervals([(39, 41), (50, 51), (48, 50), (43, 46), (42, 44)]) == [(39, 41), (42, 46), (48, 51)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_015", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_15():\n    assert merge_intervals([(45, 47), (46, 49), (51, 53), (53, 54), (49, 50)]) == [(45, 50), (51, 54)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_016", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_16():\n    assert merge_intervals([(45, 47), (56, 57), (54, 56), (49, 52), (48, 50)]) == [(45, 47), (48, 52), (54, 57)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_017", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_17():\n    assert merge_intervals([(51, 53), (52, 55), (57, 59), (59, 60)]) == [(51, 55), (57, 60)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_018", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_18():\n    assert merge_intervals([(58, 59), (51, 53), (62, 63), (60, 62), (55, 58), (54, 56)]) == [(51, 53), (54, 59), (60, 63)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_019", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_19():\n    assert merge_intervals([(57, 59), (58, 61), (63, 65), (65, 66)]) == [(57, 61), (63, 66)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_020", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_20():\n    assert merge_intervals([(57, 59), (68, 69), (66, 68), (61, 64), (60, 62)]) == [(57, 59), (60, 64), (66, 69)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_021", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_21():\n    assert merge_intervals([(63, 65), (64, 67), (69, 71), (71, 72), (67, 68)]) == [(63, 68), (69, 72)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_022", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_22():\n    assert merge_intervals([(63, 65), (74, 75), (72, 74), (67, 70), (66, 68)]) == [(63, 65), (66, 70), (72, 75)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_023", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_23():\n    assert merge_intervals([(69, 71), (70, 73), (75, 77), (77, 78)]) == [(69, 73), (75, 78)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_024", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_24():\n    assert merge_intervals([(76, 77), (69, 71), (80, 81), (78, 80), (73, 76), (72, 74)]) == [(69, 71), (72, 77), (78, 81)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_interval_merge_025", "prompt": "Fix merge_intervals so it merges overlapping or touching intervals even if input is unsorted.", "signature": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:", "starter_code": "def merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start < last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]\n", "tests": "def test_merge_intervals_25():\n    assert merge_intervals([(75, 77), (76, 79), (81, 83), (83, 84)]) == [(75, 79), (81, 84)]\n    assert merge_intervals([]) == []\n", "category": "oscillation", "topic": "interval_merge", "tier": "oscillation", "starter_check": "fail", "approaches": ["sort_and_scan", "sweep_line", "reduce"]}
{"task_id": "v11_osc_sort_001", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_1():\n    data = [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('gamma', 3), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_002", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_2():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 4), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_003", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_3():\n    data = [('alpha', 3), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 3), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_004", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_4():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_005", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_5():\n    data = [('alpha', 5), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('gamma', 3), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_006", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_6():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('alpha', 3), ('gamma', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_007", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_7():\n    data = [('alpha', 4), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 4), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_008", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_8():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_009", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_9():\n    data = [('alpha', 3), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 3), ('gamma', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_010", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_10():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('alpha', 4), ('gamma', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_011", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_11():\n    data = [('alpha', 5), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 5), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_012", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_12():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_013", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_13():\n    data = [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('gamma', 3), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_014", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_14():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 4), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_015", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_15():\n    data = [('alpha', 3), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 3), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_016", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_16():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_017", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_17():\n    data = [('alpha', 5), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('gamma', 3), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_018", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_18():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('alpha', 3), ('gamma', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_019", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_19():\n    data = [('alpha', 4), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 4), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_020", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_20():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_021", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_21():\n    data = [('alpha', 3), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 3), ('gamma', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_022", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_22():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 4), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('alpha', 4), ('gamma', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_023", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_23():\n    data = [('alpha', 5), ('beta', 2), ('gamma', 5), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 5), ('gamma', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_024", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_24():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_025", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_25():\n    data = [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('gamma', 3), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_search_001", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_1():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    assert binary_search(nums, 3) == 1\n    assert binary_search(nums, 20) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_002", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_2():\n    nums = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    assert binary_search(nums, 6) == 2\n    assert binary_search(nums, 21) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_003", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_3():\n    nums = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n    assert binary_search(nums, 9) == 3\n    assert binary_search(nums, 22) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_004", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_4():\n    nums = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22]\n    assert binary_search(nums, 12) == 4\n    assert binary_search(nums, 23) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_005", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_5():\n    nums = [5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\n    assert binary_search(nums, 15) == 5\n    assert binary_search(nums, 24) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_006", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_6():\n    nums = [6, 8, 10, 12, 14, 16, 18, 20, 22, 24]\n    assert binary_search(nums, 18) == 6\n    assert binary_search(nums, 25) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_007", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_7():\n    nums = [7, 9, 11, 13, 15, 17, 19, 21, 23, 25]\n    assert binary_search(nums, 21) == 7\n    assert binary_search(nums, 26) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_008", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_8():\n    nums = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26]\n    assert binary_search(nums, 24) == 8\n    assert binary_search(nums, 27) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_009", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_9():\n    nums = [9, 11, 13, 15, 17, 19, 21, 23, 25, 27]\n    assert binary_search(nums, 27) == 9\n    assert binary_search(nums, 28) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_010", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_10():\n    nums = [10, 12, 14, 16, 18, 20, 22, 24, 26, 28]\n    assert binary_search(nums, 10) == 0\n    assert binary_search(nums, 29) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_011", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_11():\n    nums = [11, 13, 15, 17, 19, 21, 23, 25, 27, 29]\n    assert binary_search(nums, 13) == 1\n    assert binary_search(nums, 30) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_012", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_12():\n    nums = [12, 14, 16, 18, 20, 22, 24, 26, 28, 30]\n    assert binary_search(nums, 16) == 2\n    assert binary_search(nums, 31) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_013", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_13():\n    nums = [13, 15, 17, 19, 21, 23, 25, 27, 29, 31]\n    assert binary_search(nums, 19) == 3\n    assert binary_search(nums, 32) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_014", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_14():\n    nums = [14, 16, 18, 20, 22, 24, 26, 28, 30, 32]\n    assert binary_search(nums, 22) == 4\n    assert binary_search(nums, 33) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_015", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_15():\n    nums = [15, 17, 19, 21, 23, 25, 27, 29, 31, 33]\n    assert binary_search(nums, 25) == 5\n    assert binary_search(nums, 34) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_016", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_16():\n    nums = [16, 18, 20, 22, 24, 26, 28, 30, 32, 34]\n    assert binary_search(nums, 28) == 6\n    assert binary_search(nums, 35) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_017", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_17():\n    nums = [17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n    assert binary_search(nums, 31) == 7\n    assert binary_search(nums, 36) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_018", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_18():\n    nums = [18, 20, 22, 24, 26, 28, 30, 32, 34, 36]\n    assert binary_search(nums, 34) == 8\n    assert binary_search(nums, 37) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_019", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_19():\n    nums = [19, 21, 23, 25, 27, 29, 31, 33, 35, 37]\n    assert binary_search(nums, 37) == 9\n    assert binary_search(nums, 38) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_020", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_20():\n    nums = [20, 22, 24, 26, 28, 30, 32, 34, 36, 38]\n    assert binary_search(nums, 20) == 0\n    assert binary_search(nums, 39) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_021", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_21():\n    nums = [21, 23, 25, 27, 29, 31, 33, 35, 37, 39]\n    assert binary_search(nums, 23) == 1\n    assert binary_search(nums, 40) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_022", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_22():\n    nums = [22, 24, 26, 28, 30, 32, 34, 36, 38, 40]\n    assert binary_search(nums, 26) == 2\n    assert binary_search(nums, 41) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_023", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_23():\n    nums = [23, 25, 27, 29, 31, 33, 35, 37, 39, 41]\n    assert binary_search(nums, 29) == 3\n    assert binary_search(nums, 42) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_024", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_24():\n    nums = [24, 26, 28, 30, 32, 34, 36, 38, 40, 42]\n    assert binary_search(nums, 32) == 4\n    assert binary_search(nums, 43) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_search_025", "prompt": "Fix binary_search to return the index of target, or -1 if missing.", "signature": "def binary_search(nums: list[int], target: int) -> int:", "starter_code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n", "tests": "def test_binary_search_25():\n    nums = [25, 27, 29, 31, 33, 35, 37, 39, 41, 43]\n    assert binary_search(nums, 35) == 5\n    assert binary_search(nums, 44) == -1\n", "category": "oscillation", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"]}
{"task_id": "v11_osc_heap_001", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_1():\n    h = MinHeap()\n    for v in [3, 5, 7, 5, 2]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [2, 3, 5, 5, 7]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_002", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_2():\n    h = MinHeap()\n    for v in [6, 10, 14, 6, 4]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 6, 6, 10, 14]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_003", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_3():\n    h = MinHeap()\n    for v in [9, 15, 21, 7, 6]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [6, 7, 9, 15, 21]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_004", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_4():\n    h = MinHeap()\n    for v in [12, 1, 5, 8, 8]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [1, 5, 8, 8, 12]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_005", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_5():\n    h = MinHeap()\n    for v in [15, 6, 12, 9, 10]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [6, 9, 10, 12, 15]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_006", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_6():\n    h = MinHeap()\n    for v in [1, 11, 19, 10, 12]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [1, 10, 11, 12, 19]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_007", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_7():\n    h = MinHeap()\n    for v in [4, 16, 3, 0, 1]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 1, 3, 4, 16]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_008", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_8():\n    h = MinHeap()\n    for v in [7, 2, 10, 1, 3]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [1, 2, 3, 7, 10]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_009", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_9():\n    h = MinHeap()\n    for v in [10, 7, 17, 2, 5]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [2, 5, 7, 10, 17]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_010", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_10():\n    h = MinHeap()\n    for v in [13, 12, 1, 3, 7]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [1, 3, 7, 12, 13]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_011", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_11():\n    h = MinHeap()\n    for v in [16, 17, 8, 4, 9]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 8, 9, 16, 17]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_012", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_12():\n    h = MinHeap()\n    for v in [2, 3, 15, 5, 11]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [2, 3, 5, 11, 15]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_013", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_13():\n    h = MinHeap()\n    for v in [5, 8, 22, 6, 0]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 5, 6, 8, 22]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_014", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_14():\n    h = MinHeap()\n    for v in [8, 13, 6, 7, 2]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [2, 6, 7, 8, 13]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_015", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_15():\n    h = MinHeap()\n    for v in [11, 18, 13, 8, 4]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 8, 11, 13, 18]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_016", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_16():\n    h = MinHeap()\n    for v in [14, 4, 20, 9, 6]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 6, 9, 14, 20]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_017", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_17():\n    h = MinHeap()\n    for v in [0, 9, 4, 10, 8]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 4, 8, 9, 10]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_018", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_18():\n    h = MinHeap()\n    for v in [3, 14, 11, 0, 10]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 3, 10, 11, 14]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_019", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_19():\n    h = MinHeap()\n    for v in [6, 0, 18, 1, 12]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 1, 6, 12, 18]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_020", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_20():\n    h = MinHeap()\n    for v in [9, 5, 2, 2, 1]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [1, 2, 2, 5, 9]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_021", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_21():\n    h = MinHeap()\n    for v in [12, 10, 9, 3, 3]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [3, 3, 9, 10, 12]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_022", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_22():\n    h = MinHeap()\n    for v in [15, 15, 16, 4, 5]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 5, 15, 15, 16]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_023", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_23():\n    h = MinHeap()\n    for v in [1, 1, 0, 5, 7]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [0, 1, 1, 5, 7]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_024", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_24():\n    h = MinHeap()\n    for v in [4, 6, 7, 6, 9]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [4, 6, 6, 7, 9]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_heap_025", "prompt": "Fix this MinHeap so pop() returns values in ascending order.", "signature": "class MinHeap:", "starter_code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] < self.data[idx]:\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest\n", "tests": "def test_min_heap_25():\n    h = MinHeap()\n    for v in [7, 11, 14, 7, 11]:\n        h.push(v)\n    out = [h.pop() for _ in range(5)]\n    assert out == [7, 7, 11, 11, 14]\n", "category": "oscillation", "topic": "heap", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq", "manual_sift", "sorted_list"]}
{"task_id": "v11_osc_pq_001", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_1():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_002", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_2():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_003", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_3():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_004", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_4():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_005", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_5():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_006", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_6():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_007", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_7():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_008", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_8():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_009", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_9():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_010", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_10():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_011", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_11():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_012", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_12():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_013", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_13():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_014", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_14():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_015", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_15():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_016", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_16():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_017", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_17():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_018", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_18():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_019", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_19():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_020", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_20():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_021", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_21():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_022", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_22():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_023", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_23():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 5), ('beta', 3), ('gamma', 4), ('delta', 6)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_024", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_24():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 4)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_pq_025", "prompt": "Fix this priority queue so pop() returns the smallest priority first.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, value, priority: int):\n        self.items.append((priority, value))\n        self.items.sort(reverse=True)\n\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()[1]\n", "tests": "def test_priority_queue_25():\n    pq = PriorityQueue()\n    for value, priority in [('alpha', 4), ('beta', 2), ('gamma', 3), ('delta', 5)]:\n        pq.push(value, priority)\n    out = [pq.pop() for _ in range(4)]\n    assert out == ['beta', 'gamma', 'alpha', 'delta']\n", "category": "oscillation", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_module", "sorted_list", "manual_heap"]}
{"task_id": "v11_osc_topological_sort_001", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_1():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_002", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_2():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_003", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_3():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_004", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_4():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_005", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_5():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_006", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_6():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_007", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_7():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_008", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_8():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_009", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_9():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_010", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_10():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_011", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_11():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_012", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_12():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_013", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_13():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_014", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_14():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_015", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_15():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_016", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_16():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_017", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_17():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_018", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_18():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_019", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_19():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_020", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_20():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_021", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_21():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_022", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_22():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_023", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_23():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_024", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_24():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_025", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_25():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_trie_001", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_1():\n    trie = Trie()\n    trie.insert('word1')\n    assert trie.search('word1') is True\n    assert trie.search('word') is False\n    assert trie.search('w1x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_002", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_2():\n    trie = Trie()\n    trie.insert('word2')\n    assert trie.search('word2') is True\n    assert trie.search('word') is False\n    assert trie.search('w2x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_003", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_3():\n    trie = Trie()\n    trie.insert('word3')\n    assert trie.search('word3') is True\n    assert trie.search('word') is False\n    assert trie.search('w3x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_004", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_4():\n    trie = Trie()\n    trie.insert('word4')\n    assert trie.search('word4') is True\n    assert trie.search('word') is False\n    assert trie.search('w4x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_005", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_5():\n    trie = Trie()\n    trie.insert('word5')\n    assert trie.search('word5') is True\n    assert trie.search('word') is False\n    assert trie.search('w5x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_006", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_6():\n    trie = Trie()\n    trie.insert('word6')\n    assert trie.search('word6') is True\n    assert trie.search('word') is False\n    assert trie.search('w6x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_007", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_7():\n    trie = Trie()\n    trie.insert('word7')\n    assert trie.search('word7') is True\n    assert trie.search('word') is False\n    assert trie.search('w7x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_008", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_8():\n    trie = Trie()\n    trie.insert('word8')\n    assert trie.search('word8') is True\n    assert trie.search('word') is False\n    assert trie.search('w8x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_009", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_9():\n    trie = Trie()\n    trie.insert('word9')\n    assert trie.search('word9') is True\n    assert trie.search('word') is False\n    assert trie.search('w9x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_010", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_10():\n    trie = Trie()\n    trie.insert('word10')\n    assert trie.search('word10') is True\n    assert trie.search('word1') is False\n    assert trie.search('w10x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_011", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_11():\n    trie = Trie()\n    trie.insert('word11')\n    assert trie.search('word11') is True\n    assert trie.search('word1') is False\n    assert trie.search('w11x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_012", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_12():\n    trie = Trie()\n    trie.insert('word12')\n    assert trie.search('word12') is True\n    assert trie.search('word1') is False\n    assert trie.search('w12x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_013", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_13():\n    trie = Trie()\n    trie.insert('word13')\n    assert trie.search('word13') is True\n    assert trie.search('word1') is False\n    assert trie.search('w13x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_014", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_14():\n    trie = Trie()\n    trie.insert('word14')\n    assert trie.search('word14') is True\n    assert trie.search('word1') is False\n    assert trie.search('w14x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_015", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_15():\n    trie = Trie()\n    trie.insert('word15')\n    assert trie.search('word15') is True\n    assert trie.search('word1') is False\n    assert trie.search('w15x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_016", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_16():\n    trie = Trie()\n    trie.insert('word16')\n    assert trie.search('word16') is True\n    assert trie.search('word1') is False\n    assert trie.search('w16x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_017", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_17():\n    trie = Trie()\n    trie.insert('word17')\n    assert trie.search('word17') is True\n    assert trie.search('word1') is False\n    assert trie.search('w17x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_018", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_18():\n    trie = Trie()\n    trie.insert('word18')\n    assert trie.search('word18') is True\n    assert trie.search('word1') is False\n    assert trie.search('w18x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_019", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_19():\n    trie = Trie()\n    trie.insert('word19')\n    assert trie.search('word19') is True\n    assert trie.search('word1') is False\n    assert trie.search('w19x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_020", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_20():\n    trie = Trie()\n    trie.insert('word20')\n    assert trie.search('word20') is True\n    assert trie.search('word2') is False\n    assert trie.search('w20x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_021", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_21():\n    trie = Trie()\n    trie.insert('word21')\n    assert trie.search('word21') is True\n    assert trie.search('word2') is False\n    assert trie.search('w21x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_022", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_22():\n    trie = Trie()\n    trie.insert('word22')\n    assert trie.search('word22') is True\n    assert trie.search('word2') is False\n    assert trie.search('w22x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_023", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_23():\n    trie = Trie()\n    trie.insert('word23')\n    assert trie.search('word23') is True\n    assert trie.search('word2') is False\n    assert trie.search('w23x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_024", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_24():\n    trie = Trie()\n    trie.insert('word24')\n    assert trie.search('word24') is True\n    assert trie.search('word2') is False\n    assert trie.search('w24x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
{"task_id": "v11_osc_trie_025", "prompt": "Fix Trie search so it only returns True for complete words.", "signature": "class Trie:", "starter_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n", "tests": "def test_trie_search_25():\n    trie = Trie()\n    trie.insert('word25')\n    assert trie.search('word25') is True\n    assert trie.search('word2') is False\n    assert trie.search('w25x') is False\n", "category": "oscillation", "topic": "trie", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"]}
