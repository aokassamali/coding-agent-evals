{"task_id": "v11_osc_string_match_004", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_4():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_007", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_7():\n    assert find_all_indices('ababababa', 'aba') == [0, 2, 4, 6]\n    assert find_all_indices('ababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_009", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_9():\n    assert find_all_indices('mississippi', 'issi') == [1, 4]\n    assert find_all_indices('mississippi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_011", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_11():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_012", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_12():\n    assert find_all_indices('abababa', 'aba') == [0, 2, 4]\n    assert find_all_indices('abababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_014", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_14():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_016", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_16():\n    assert find_all_indices('aaaaaa', 'aa') == [0, 1, 2, 3, 4]\n    assert find_all_indices('aaaaaa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_017", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_17():\n    assert find_all_indices('abababababa', 'aba') == [0, 2, 4, 6, 8]\n    assert find_all_indices('abababababa', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_019", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_19():\n    assert find_all_indices('mississippi', 'issi') == [1, 4]\n    assert find_all_indices('mississippi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_string_match_024", "prompt": "Fix this function so it returns all start indices of pattern in text, including overlaps.", "signature": "def find_all_indices(text: str, pattern: str) -> list:", "starter_code": "def find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices\n", "tests": "def test_find_all_indices_24():\n    assert find_all_indices('mississippissi', 'issi') == [1, 4, 10]\n    assert find_all_indices('mississippissi', \"zzz\") == []\n", "category": "oscillation", "topic": "string_match", "tier": "oscillation", "starter_check": "fail", "approaches": ["kmp", "rabin_karp", "naive", "builtin"]}
{"task_id": "v11_osc_sort_004", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_4():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_008", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_8():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_009", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_9():\n    data = [('alpha', 3), ('beta', 2), ('gamma', 3), ('delta', 1)]\n    assert sort_pairs(data) == [('delta', 1), ('beta', 2), ('alpha', 3), ('gamma', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_012", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_12():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_016", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_16():\n    data = [('alpha', 4), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 4)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_020", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_20():\n    data = [('alpha', 5), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 5)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_sort_024", "prompt": "Fix this function so it sorts pairs by score ascending, then by name.", "signature": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:", "starter_code": "def sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    pairs.sort()\n    return pairs\n", "tests": "def test_sort_pairs_24():\n    data = [('alpha', 3), ('beta', 1), ('gamma', 2), ('delta', 2)]\n    assert sort_pairs(data) == [('beta', 1), ('delta', 2), ('gamma', 2), ('alpha', 3)]\n", "category": "oscillation", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["quicksort", "mergesort", "builtin", "iterative"]}
{"task_id": "v11_osc_topological_sort_001", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_1():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_002", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_2():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_003", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_3():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_004", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_4():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_005", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_5():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_006", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_6():\n    graph = {'A': ['C', 'E'], 'B': ['C', 'E'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_008", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_8():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_010", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_10():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_011", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_11():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_013", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_13():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_014", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_14():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_016", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_16():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_020", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_20():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_022", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_22():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': ['F'], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_023", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_23():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
{"task_id": "v11_osc_topological_sort_025", "prompt": "Fix topo_sort so it returns a valid topological ordering for the DAG.", "signature": "def topo_sort(graph: dict) -> list:", "starter_code": "def topo_sort(graph: dict) -> list:\n    visited = set()\n    order = []\n\n    def dfs(node):\n        if node in visited:\n            return\n        for nbr in graph.get(node, []):\n            dfs(nbr)\n        order.append(node)\n        visited.add(node)\n\n    for node in graph:\n        dfs(node)\n    return order\n", "tests": "def _is_valid_topo(order, graph):\n    if len(order) != len(graph):\n        return False\n    pos = {n: i for i, n in enumerate(order)}\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            if pos[u] > pos[v]:\n                return False\n    return True\n\ndef test_topo_sort_25():\n    graph = {'A': ['C', 'E'], 'B': ['C'], 'C': ['D'], 'D': [], 'E': [], 'F': []}\n    order = topo_sort(graph)\n    assert _is_valid_topo(order, graph) is True\n", "category": "oscillation", "topic": "topological_sort", "tier": "oscillation", "starter_check": "fail", "approaches": ["dfs_postorder", "kahns_bfs", "recursive"]}
