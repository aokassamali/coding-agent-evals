{"task_id": "bug_return_none_01", "prompt": "Fix this function so it returns True when x is positive, instead of None.", "signature": "def is_positive(x: int) -> bool:", "starter_code": "def is_positive(x: int) -> bool:\n    if x > 0:\n        return True\n    # missing return\n", "tests": "def test_is_positive():\n    assert is_positive(5) == True\n    assert is_positive(-1) == False\n    assert is_positive(0) == False\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_offbyone_02", "prompt": "Fix the loop so it includes the last element of the list.", "signature": "def sum_all(arr: list) -> int:", "starter_code": "def sum_all(arr: list) -> int:\n    total = 0\n    for i in range(len(arr) - 1):  # off by one\n        total += arr[i]\n    return total\n", "tests": "def test_sum_all():\n    assert sum_all([1,2,3]) == 6\n    assert sum_all([5]) == 5\n    assert sum_all([]) == 0\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_scope_03", "prompt": "Fix the variable scope issue so total is accessible when returning.", "signature": "def count_evens(nums: list) -> int:", "starter_code": "def count_evens(nums: list) -> int:\n    if nums:\n        total = 0\n    for n in nums:\n        if n % 2 == 0:\n            total += 1\n    return total\n", "tests": "def test_count_evens():\n    assert count_evens([1,2,3,4]) == 2\n    assert count_evens([]) == 0\n    assert count_evens([2,4,6]) == 3\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_string_concat_04", "prompt": "Fix this to return a string, not accumulate integers.", "signature": "def concat_digits(nums: list) -> str:", "starter_code": "def concat_digits(nums: list) -> str:\n    result = 0\n    for n in nums:\n        result += str(n)\n    return result\n", "tests": "def test_concat_digits():\n    assert concat_digits([1,2,3]) == \"123\"\n    assert concat_digits([]) == \"\"\n    assert concat_digits([5]) == \"5\"\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_zero_division_05", "prompt": "Fix to handle empty list without crashing (avoid division by zero).", "signature": "def average(nums: list) -> float:", "starter_code": "def average(nums: list) -> float:\n    return sum(nums) / len(nums)\n", "tests": "def test_average():\n    assert average([10,20,30]) == 20.0\n    assert average([5]) == 5.0\n    assert average([]) == 0.0\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_negative_index_06", "prompt": "Fix this to handle negative indices correctly (return None if out of bounds).", "signature": "def safe_get(arr: list, idx: int):", "starter_code": "def safe_get(arr: list, idx: int):\n    if idx < len(arr):\n        return arr[idx]\n    return None\n", "tests": "def test_safe_get():\n    assert safe_get([1,2,3], 1) == 2\n    assert safe_get([1], 5) == None\n    assert safe_get([1,2,3], -1) == 3\n    assert safe_get([1,2], -5) == None\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_mutable_default_07", "prompt": "Fix the mutable default argument bug so subsequent calls don't accumulate state.", "signature": "def append_item(item, lst=[]):", "starter_code": "def append_item(item, lst=[]):\n    lst.append(item)\n    return lst\n", "tests": "def test_append_item():\n    assert append_item(1) == [1]\n    assert append_item(2) == [2]\n    assert append_item(3, [0]) == [0, 3]\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_float_compare_08", "prompt": "Fix the floating point comparison (do not use exact equality for floats).", "signature": "def is_approx_equal(a: float, b: float) -> bool:", "starter_code": "def is_approx_equal(a: float, b: float) -> bool:\n    return a == b\n", "tests": "def test_is_approx_equal():\n    assert is_approx_equal(0.1 + 0.2, 0.3) == True\n    assert is_approx_equal(1.0, 1.0000000001) == True\n    assert is_approx_equal(1.0, 2.0) == False\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_type_mismatch_09", "prompt": "Fix to handle both int and float inputs without type errors in string concatenation.", "signature": "def format_number(n) -> str:", "starter_code": "def format_number(n) -> str:\n    return \"Value: \" + n\n", "tests": "def test_format_number():\n    assert format_number(42) == \"Value: 42\"\n    assert format_number(3.14) == \"Value: 3.14\"\n    assert format_number(\"hello\") == \"Value: hello\"\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_early_return_10", "prompt": "Fix the logic error where the function exits too early (check all conditions).", "signature": "def grade(score: int) -> str:", "starter_code": "def grade(score: int) -> str:\n    if score >= 90:\n        return \"A\"\n    if score >= 80:\n        return \"B\"\n    if score >= 70:\n        return \"C\"\n    return \"F\"\n", "tests": "def test_grade():\n    assert grade(95) == \"A\"\n    assert grade(85) == \"B\"\n    assert grade(75) == \"C\"\n    assert grade(65) == \"F\"\n    assert grade(0) == \"F\"\n", "category": "stability_noop", "topic": "misc", "starter_check": "pass"}
{"task_id": "bug_string_strip_11", "prompt": "Fix to handle strings with whitespace padding correctly (must work with leading/trailing spaces).", "signature": "def extract_number(s: str) -> int:", "starter_code": "def extract_number(s: str) -> int:\n    if s[0] == \"#\":\n        return int(s[1:])\n    return int(s)\n", "tests": "def test_extract_number():\n    assert extract_number(\"  #123\") == 123\n    assert extract_number(\"42  \") == 42\n    assert extract_number(\"  99  \") == 99\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_infinite_loop_12", "prompt": "Fix the infinite loop (ensure progress is made toward termination).", "signature": "def countdown(n: int) -> list:", "starter_code": "def countdown(n: int) -> list:\n    result = []\n    while n > 0:\n        result.append(n)\n    return result\n", "tests": "def test_countdown():\n    assert countdown(3) == [3, 2, 1]\n    assert countdown(0) == []\n    assert countdown(1) == [1]\n", "category": "hang_timeout", "topic": "float_precision", "starter_check": "timeout"}
{"task_id": "bug_shadow_builtin_13", "prompt": "Fix the variable name shadowing that breaks the built-in function.", "signature": "def find_max_sum(lists: list) -> int:", "starter_code": "def find_max_sum(lists: list) -> int:\n    max = 0\n    for lst in lists:\n        s = sum(lst)\n        if s > max:\n            max = s\n    return max\n", "tests": "def test_find_max_sum():\n    assert find_max_sum([[1,2], [3,4,5]]) == 12\n    assert find_max_sum([[], [1]]) == 1\n    assert find_max_sum([]) == 0\n", "category": "stability_noop", "topic": "misc", "starter_check": "pass"}
{"task_id": "bug_list_multiplication_14", "prompt": "Fix the list multiplication bug creating shared references (each sublist must be independent).", "signature": "def create_matrix(rows: int, cols: int) -> list:", "starter_code": "def create_matrix(rows: int, cols: int) -> list:\n    return [[0] * cols] * rows\n", "tests": "def test_create_matrix():\n    m = create_matrix(2, 3)\n    m[0][0] = 1\n    assert m[1][0] == 0\n    assert len(m) == 2 and len(m[0]) == 3\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_keyerror_15", "prompt": "Fix to handle missing keys gracefully (return 0 if key not found).", "signature": "def get_count(counter: dict, key: str) -> int:", "starter_code": "def get_count(counter: dict, key: str) -> int:\n    return counter[key]\n", "tests": "def test_get_count():\n    assert get_count({\"a\": 5}, \"a\") == 5\n    assert get_count({\"a\": 5}, \"b\") == 0\n    assert get_count({}, \"x\") == 0\n", "category": "bugfix", "topic": "concurrency", "starter_check": "fail"}
{"task_id": "bug_modulo_negative_16", "prompt": "Fix modulo handling so it returns positive remainder for negative inputs (mathematical modulo, not C-style).", "signature": "def positive_mod(n: int, m: int) -> int:", "starter_code": "def positive_mod(n: int, m: int) -> int:\n    return n % m\n", "tests": "def test_positive_mod():\n    assert positive_mod(17, 5) == 2\n    assert positive_mod(-17, 5) == 3\n    assert positive_mod(17, -5) == -3  # or handle consistently\n    assert positive_mod(-5, 3) == 1\n", "category": "stability_noop", "topic": "misc", "starter_check": "pass"}
{"task_id": "bug_recursion_depth_17", "prompt": "Fix the stack overflow on large inputs (convert recursion to iteration or memoization). Must handle n=10000 without recursion depth error.", "signature": "def fibonacci(n: int) -> int:", "starter_code": "def fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n", "tests": "def test_fibonacci():\n    assert fibonacci(0) == 0\n    assert fibonacci(1) == 1\n    assert fibonacci(10) == 55\n    assert fibonacci(100) == 354224848179261915075\n    assert fibonacci(10000) > 0\n", "category": "hang_timeout", "topic": "float_precision", "starter_check": "timeout"}
{"task_id": "bug_dict_iteration_18", "prompt": "Fix the dict modification during iteration bug.", "signature": "def remove_negatives(d: dict) -> dict:", "starter_code": "def remove_negatives(d: dict) -> dict:\n    for k, v in d.items():\n        if v < 0:\n            del d[k]\n    return d\n", "tests": "def test_remove_negatives():\n    assert remove_negatives({\"a\": 1, \"b\": -2, \"c\": 3}) == {\"a\": 1, \"c\": 3}\n    assert remove_negatives({\"x\": -5, \"y\": -10}) == {}\n    assert remove_negatives({\"a\": 1}) == {\"a\": 1}\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_precision_accum_19", "prompt": "Fix the floating point precision accumulation error when summing many small floats.", "signature": "def precise_sum(numbers: list) -> float:", "starter_code": "def precise_sum(numbers: list) -> float:\n    total = 0.0\n    for n in numbers:\n        total += n\n    return total\n", "tests": "def test_precise_sum():\n    # Kahan summation or math.fsum needed\n    small = [0.1] * 10\n    result = precise_sum(small)\n    assert abs(result - 1.0) < 1e-15\n    assert precise_sum([1e100, 1, -1e100]) == 1.0\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_mutable_input_20", "prompt": "Fix to not mutate the original input list (must return new list, leave input unchanged).", "signature": "def reverse_list(items: list) -> list:", "starter_code": "def reverse_list(items: list) -> list:\n    items.reverse()\n    return items\n", "tests": "def test_reverse_list():\n    original = [1, 2, 3]\n    result = reverse_list(original)\n    assert result == [3, 2, 1]\n    assert original == [1, 2, 3]\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_closure_late_binding_21", "prompt": "Fix the late binding closure bug so each function gets its correct value.", "signature": "def create_multipliers():", "starter_code": "def create_multipliers():\n    return [lambda x: i * x for i in range(5)]\n", "tests": "def test_create_multipliers():\n    multipliers = create_multipliers()\n    assert multipliers[0](2) == 0\n    assert multipliers[1](2) == 2\n    assert multipliers[2](2) == 4\n    assert multipliers[4](2) == 8\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_binary_search_22", "prompt": "Fix the infinite loop in this binary search implementation.", "signature": "def binary_search(arr: list, target: int) -> int:", "starter_code": "def binary_search(arr: list, target: int) -> int:\n    left, right = 0, len(arr)\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid\n        else:\n            right = mid\n    return -1\n", "tests": "def test_binary_search():\n    assert binary_search([1,3,5,7,9], 5) == 2\n    assert binary_search([1,3,5], 2) == -1\n    assert binary_search([], 5) == -1\n    assert binary_search([5], 5) == 0\n", "category": "hang_timeout", "topic": "float_precision", "starter_check": "timeout"}
{"task_id": "bug_sum_overflow_23", "prompt": "Fix to handle very large integers without overflow concerns (use appropriate type handling).", "signature": "def safe_product(a: int, b: int) -> int:", "starter_code": "def safe_product(a: int, b: int) -> int:\n    return a * b  # Python handles big ints, but verify logic\n", "tests": "def test_safe_product():\n    assert safe_product(2, 3) == 6\n    assert safe_product(0, 999999) == 0\n    assert safe_product(-1, 10) == -10\n    assert safe_product(123456789, 987654321) == 121932631112635269\n", "category": "stability_noop", "topic": "float_precision", "starter_check": "pass"}
{"task_id": "bug_sort_key_24", "prompt": "Fix to sort correctly by numeric value rather than lexicographically.", "signature": "def sort_by_number(strings: list) -> list:", "starter_code": "def sort_by_number(strings: list) -> list:\n    return sorted(strings)\n", "tests": "def test_sort_by_number():\n    assert sort_by_number([\"item10\", \"item2\", \"item1\"]) == [\"item1\", \"item2\", \"item10\"]\n    assert sort_by_number([\"5\", \"-3\", \"0\"]) == [\"-3\", \"0\", \"5\"]\n", "category": "bugfix", "topic": "collections_algorithms", "starter_check": "fail"}
{"task_id": "bug_generator_exhaust_25", "prompt": "Fix the generator exhaustion bug (you can only iterate once).", "signature": "def count_lines(files: list) -> int:", "starter_code": "def count_lines(files: list) -> int:\n    lines = (open(f).readlines() for f in files)\n    total = sum(len(list(lines)) for f in files)\n    return total\n", "tests": "def test_count_lines():\n    import tempfile, os\n    with tempfile.TemporaryDirectory() as tmp:\n        f1 = os.path.join(tmp, \"a.txt\")\n        f2 = os.path.join(tmp, \"b.txt\")\n        with open(f1, 'w') as f: f.write(\"line1\\nline2\\n\")\n        with open(f2, 'w') as f: f.write(\"line3\\n\")\n        assert count_lines([f1, f2]) == 3\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_timer_26", "prompt": "Fix this timeout-prone implementation to run in O(n) time instead of O(2^n). The current recursive approach is too slow for n=35.", "signature": "def unique_paths(m: int, n: int) -> int:", "starter_code": "def unique_paths(m: int, n: int) -> int:\n    if m == 1 or n == 1:\n        return 1\n    return unique_paths(m-1, n) + unique_paths(m, n-1)\n", "tests": "def test_unique_paths():\n    assert unique_paths(3, 7) == 28\n    assert unique_paths(3, 2) == 3\n    assert unique_paths(10, 10) == 48620\n    assert unique_paths(35, 35) > 0\n", "category": "hang_timeout", "topic": "datetime_timezone", "starter_check": "timeout"}
{"task_id": "bug_nan_handling_27", "prompt": "Fix to properly detect NaN values (NaN != NaN).", "signature": "def has_invalid(data: list) -> bool:", "starter_code": "def has_invalid(data: list) -> bool:\n    for x in data:\n        if x == float('nan'):\n            return True\n    return False\n", "tests": "def test_has_invalid():\n    import math\n    assert has_invalid([1.0, 2.0, float('nan')]) == True\n    assert has_invalid([1.0, 2.0, 3.0]) == False\n    assert has_invalid([]) == False\n    assert has_invalid([float('nan')]) == True\n", "category": "bugfix", "topic": "float_precision", "starter_check": "fail"}
{"task_id": "bug_zero_float_28", "prompt": "Fix the sign handling for negative zero (-0.0 should return True for is_negative).", "signature": "def is_negative_zero(x: float) -> bool:", "starter_code": "def is_negative_zero(x: float) -> bool:\n    return x == 0 and str(x)[0] == '-'\n", "tests": "def test_is_negative_zero():\n    assert is_negative_zero(-0.0) == True\n    assert is_negative_zero(0.0) == False\n    assert is_negative_zero(5.0) == False\n    assert is_negative_zero(-5.0) == False\n", "category": "stability_noop", "topic": "float_precision", "starter_check": "pass"}
{"task_id": "bug_unicode_29", "prompt": "Fix to handle Unicode characters correctly when counting string length (grapheme clusters vs codepoints).", "signature": "def char_length(s: str) -> int:", "starter_code": "def char_length(s: str) -> int:\n    return len(s)\n", "tests": "def test_char_length():\n    assert char_length(\"hello\") == 5\n    assert char_length(\"ðŸš€\") == 1\n    assert char_length(\"ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦\") == 1\n", "category": "bugfix", "topic": "unicode_text", "starter_check": "fail"}
{"task_id": "bug_flatten_nested_30", "prompt": "Fix the recursion error on deeply nested lists (must handle arbitrary depth iteratively).", "signature": "def flatten_deep(nested: list) -> list:", "starter_code": "def flatten_deep(nested: list) -> list:\n    result = []\n    for item in nested:\n        if isinstance(item, list):\n            result.extend(flatten_deep(item))\n        else:\n            result.append(item)\n    return result\n", "tests": "def test_flatten_deep():\n    assert flatten_deep([1, [2, 3], 4]) == [1, 2, 3, 4]\n    assert flatten_deep([[[]]]) == []\n    deep = [[i] for i in range(2000)]\n    assert flatten_deep(deep) == list(range(2000))\n", "category": "stability_noop", "topic": "collections_algorithms", "starter_check": "pass"}
{"task_id": "bug_timezone_31", "prompt": "Fix the timezone naive vs aware comparison bug.", "signature": "def is_older(dt1, dt2) -> bool:", "starter_code": "def is_older(dt1, dt2) -> bool:\n    from datetime import datetime\n    return dt1 < dt2\n", "tests": "def test_is_older():\n    from datetime import datetime, timezone\n    naive = datetime.now()\n    aware = datetime.now(timezone.utc)\n    assert is_older(naive.replace(tzinfo=None), aware.replace(tzinfo=None)) in [True, False]\n    # Just ensure no TypeError is raised\n    dt1 = datetime(2023, 1, 1, 12, 0, 0)\n    dt2 = datetime(2023, 1, 1, 12, 0, 1)\n    assert is_older(dt1, dt2) == True\n", "category": "stability_noop", "topic": "datetime_timezone", "starter_check": "pass"}
{"task_id": "bug_partial_function_32", "prompt": "Fix the mutable default argument in function factory that causes shared state.", "signature": "def make_adder(x, cache={}):", "starter_code": "def make_adder(x, cache={}):\n    def adder(y):\n        cache[x+y] = True\n        return x + y\n    return adder\n", "tests": "def test_make_adder():\n    add5 = make_adder(5)\n    add10 = make_adder(10)\n    assert add5(3) == 8\n    assert add10(3) == 13\n    # They should not share cache\n    assert len(add5.__closure__[0].cell_contents) == 1\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_weakref_33", "prompt": "Fix the premature garbage collection issue with weak references.", "signature": "def cache_value(key: str, value):", "starter_code": "def cache_value(key: str, value):\n    import weakref\n    cache = {}\n    cache[key] = weakref.ref(value)\n    return cache[key]()\n", "tests": "def test_cache_value():\n    class Obj:\n        pass\n    obj = Obj()\n    result = cache_value(\"test\", obj)\n    assert result is obj\n", "category": "stability_noop", "topic": "gc_weakref", "starter_check": "pass"}
{"task_id": "bug_regex_backref_34", "prompt": "Fix the regex to properly match repeated words (backreference issue).", "signature": "import re\ndef find_doubles(text: str) -> list:", "starter_code": "import re\ndef find_doubles(text: str) -> list:\n    return re.findall(r'(\\w+)\\s+\\1', text, re.IGNORECASE)\n", "tests": "def test_find_doubles():\n    assert find_doubles(\"hello hello world\") == [\"hello\"]\n    assert find_doubles(\"the the the\") == [\"the\"]\n    assert find_doubles(\"no doubles\") == []\n", "category": "stability_noop", "topic": "regex", "starter_check": "pass"}
{"task_id": "bug_async_sync_mix_35", "prompt": "Fix the mixing of sync and async code causing RuntimeError.", "signature": "import asyncio\nasync def fetch_data(url: str) -> str:", "starter_code": "import asyncio\nasync def fetch_data(url: str) -> str:\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(asyncio.sleep(0.1))\n", "tests": "def test_fetch_data():\n    import asyncio\n    async def test():\n        result = await fetch_data(\"test\")\n        return result\n    assert asyncio.run(test()) is None\n", "category": "bugfix", "topic": "asyncio", "starter_check": "fail"}
{"task_id": "bug_descriptor_36", "prompt": "Fix the descriptor protocol implementation so validation works on instances.", "signature": "class Validator:\n    def __init__(self, min_val):", "starter_code": "class Validator:\n    def __init__(self, min_val):\n        self.min_val = min_val\n    def __get__(self, obj, objtype=None):\n        return obj._value\n    def __set__(self, obj, value):\n        if value < self.min_val:\n            raise ValueError(\"Too small\")\n        obj._value = value\n\nclass Item:\n    price = Validator(0)\n    def __init__(self):\n        self._value = None\n", "tests": "def test_validator():\n    item = Item()\n    item.price = 10\n    assert item.price == 10\n    try:\n        item.price = -5\n        raise AssertionError(\"Should have raised\")\n    except ValueError:\n        pass\n", "category": "stability_noop", "topic": "object_model", "starter_check": "pass"}
{"task_id": "bug_metaclass_conflict_37", "prompt": "Fix the metaclass conflict when inheriting from dict and using custom metaclass.", "signature": "def create_ordered_class():", "starter_code": "def create_ordered_class():\n    from collections import OrderedDict\n    class Meta(type):\n        @classmethod\n        def __prepare__(mcs, name, bases):\n            return OrderedDict()\n    class MyClass(dict, metaclass=Meta):\n        pass\n    return MyClass\n", "tests": "def test_create_ordered_class():\n    cls = create_ordered_class()\n    obj = cls()\n    obj['a'] = 1\n    assert obj['a'] == 1\n", "category": "stability_noop", "topic": "object_model", "starter_check": "pass"}
{"task_id": "bug_memoryview_38", "prompt": "Fix the memory view mutation that unexpectedly modifies the original bytes. Must return copy.", "signature": "def process_bytes(data: bytes) -> bytes:", "starter_code": "def process_bytes(data: bytes) -> bytes:\n    mv = memoryview(bytearray(data))\n    for i in range(len(mv)):\n        mv[i] ^= 0xFF\n    return bytes(mv)\n", "tests": "def test_process_bytes():\n    original = b'\\x00\\x01\\x02'\n    result = process_bytes(original)\n    assert result == b'\\xff\\xfe\\xfd'\n    assert original == b'\\x00\\x01\\x02'\n", "category": "stability_noop", "topic": "io_bytes", "starter_check": "pass"}
{"task_id": "bug_weak_method_39", "prompt": "Fix the weakref to bound method that dies immediately.", "signature": "import weakref\ndef monitor_object(obj):", "starter_code": "import weakref\ndef monitor_object(obj):\n    def callback(ref):\n        print(\"Dead\")\n    ref = weakref.ref(obj.callback, callback)\n    return ref\n\nclass Button:\n    def callback(self):\n        pass\n", "tests": "def test_monitor_object():\n    button = Button()\n    ref = monitor_object(button)\n    assert ref() is not None\n    del button\n    import gc\n    gc.collect()\n    assert ref() is None\n", "category": "bugfix", "topic": "gc_weakref", "starter_check": "fail"}
{"task_id": "bug_contextmanager_40", "prompt": "Fix the context manager that swallows exceptions incorrectly.", "signature": "from contextlib import contextmanager\n@contextmanager\ndef temp_state(obj):", "starter_code": "from contextlib import contextmanager\n@contextmanager\ndef temp_state(obj):\n    old = obj.value\n    obj.value = 'temp'\n    yield\n    obj.value = old\n    return True  # This swallows exceptions!\n", "tests": "def test_temp_state():\n    class Obj:\n        value = 'original'\n    obj = Obj()\n    try:\n        with temp_state(obj):\n            assert obj.value == 'temp'\n            raise ValueError(\"test\")\n    except ValueError:\n        pass\n    assert obj.value == 'original'\n", "category": "bugfix", "topic": "misc", "starter_check": "fail"}
{"task_id": "bug_descriptor_return_41", "prompt": "Fix the property that returns descriptor instead of value.", "signature": "class Circle:", "starter_code": "class Circle:\n    def __init__(self, radius):\n        self._r = radius\n    \n    @property\n    def diameter(self):\n        return self._r * 2\n    \n    @diameter.setter\n    def diameter(self, value):\n        self._r = value / 2\n    \n    area = property(lambda self: 3.14159 * self._r ** 2)\n", "tests": "def test_circle():\n    c = Circle(5)\n    assert c.diameter == 10\n    c.diameter = 20\n    assert c._r == 10\n    assert c.area > 314\n    assert isinstance(c.area, float)\n", "category": "stability_noop", "topic": "object_model", "starter_check": "pass"}
{"task_id": "bug_slots_inheritance_42", "prompt": "Fix the slots inheritance that breaks attribute access in subclass.", "signature": "class Base:", "starter_code": "class Base:\n    __slots__ = ['a', 'b']\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n\nclass Child(Base):\n    def __init__(self):\n        super().__init__()\n        self.c = 3\n", "tests": "def test_slots():\n    child = Child()\n    assert child.a == 1\n    assert child.b == 2\n    assert child.c == 3\n", "category": "stability_noop", "topic": "object_model", "starter_check": "pass"}
{"task_id": "bug_pickle_protocol_43", "prompt": "Fix the unpicklable object due to closure reference. Must be serializable.", "signature": "import pickle\ndef create_config(name: str):", "starter_code": "import pickle\ndef create_config(name: str):\n    default = {'verbose': True}\n    class Config:\n        def __init__(self):\n            self.name = name\n            self.settings = default\n    return Config()\n", "tests": "def test_create_config():\n    config = create_config(\"test\")\n    assert config.name == \"test\"\n    data = pickle.dumps(config)\n    restored = pickle.loads(data)\n    assert restored.name == \"test\"\n", "category": "bugfix", "topic": "serialization_pickle", "starter_check": "fail"}
{"task_id": "bug_atexit_44", "prompt": "Fix the atexit handler that captures mutable global state incorrectly.", "signature": "import atexit\ndef setup_loggers():", "starter_code": "import atexit\nlogs = []\n\ndef register_cleanup(msg):\n    def cleanup():\n        logs.append(msg)\n        print(f\"Cleaning {msg}\")\n    atexit.register(cleanup)\n\ndef setup_loggers():\n    for msg in [\"a\", \"b\", \"c\"]:\n        register_cleanup(msg)\n", "tests": "def test_atexit():\n    import atexit\n    old_handlers = atexit._exithandlers[:]\n    atexit._exithandlers.clear()\n    setup_loggers()\n    assert len(atexit._exithandlers) == 3\n    atexit._exithandlers.clear()\n    atexit._exithandlers.extend(old_handlers)\n", "category": "bugfix", "topic": "gc_weakref", "starter_check": "fail"}
{"task_id": "bug_semaphore_45", "prompt": "Fix the semaphore leak in error path (resource not released on exception).", "signature": "import threading\ndef limited_work(sem: threading.Semaphore, should_fail: bool):", "starter_code": "import threading\ndef limited_work(sem: threading.Semaphore, should_fail: bool):\n    sem.acquire()\n    if should_fail:\n        raise ValueError(\"Oops\")\n    sem.release()\n", "tests": "def test_semaphore():\n    sem = threading.Semaphore(2)\n    try:\n        limited_work(sem, True)\n    except ValueError:\n        pass\n    # Semaphore should still have 2 available\n    assert sem.acquire(blocking=False)\n    assert sem.acquire(blocking=False)\n    assert not sem.acquire(blocking=False)\n", "category": "bugfix", "topic": "concurrency", "starter_check": "fail"}
{"task_id": "bug_int_subclass_46", "prompt": "Fix the int subclass that breaks hash consistency (equal objects must have same hash).", "signature": "class Temperature(int):", "starter_code": "class Temperature(int):\n    def __init__(self, value, scale='C'):\n        self.scale = scale\n    def __eq__(self, other):\n        if isinstance(other, Temperature):\n            return int(self) == int(other)\n        return False\n", "tests": "def test_temperature():\n    t1 = Temperature(20, 'C')\n    t2 = Temperature(20, 'F')\n    assert t1 == t2\n    assert hash(t1) == hash(t2)\n    d = {t1: 'value'}\n    assert d[t2] == 'value'\n", "category": "bugfix", "topic": "object_model", "starter_check": "fail"}
{"task_id": "bug_inline_cache_47", "prompt": "Fix the function that assumes dict iteration order for optimization but fails on older Python semantics.", "signature": "def optimize_access(obj: dict) -> list:", "starter_code": "def optimize_access(obj: dict) -> list:\n    # Assume keys are in insertion order (Python 3.7+)\n    return [obj[k] for k in sorted(obj.keys()) if k.startswith('data_')]\n", "tests": "def test_optimize_access():\n    d = {'data_z': 1, 'data_a': 2, 'other': 3}\n    result = optimize_access(d)\n    assert result == [2, 1]\n    d['data_m'] = 4\n    result = optimize_access(d)\n    assert result == [2, 4, 1]\n", "category": "stability_noop", "topic": "collections_algorithms", "starter_check": "pass"}
{"task_id": "bug_circular_import_48", "prompt": "Fix the circular import that causes AttributeError on module load.", "signature": "# module_a.py equivalent\ndef get_value():", "starter_code": "# module_a.py equivalent\ndef get_value():\n    from module_b import helper\n    return helper() + 1\n\n# module_b.py equivalent  \ndef helper():\n    from module_a import get_value\n    return 5\n", "tests": "def test_circular():\n    import sys\n    modules = sys.modules.copy()\n    try:\n        # Simulate in one file\n        import types\n        mod_a = types.ModuleType('module_a')\n        mod_b = types.ModuleType('module_b')\n        sys.modules['module_a'] = mod_a\n        sys.modules['module_b'] = mod_b\n        exec(\"def get_value():\\n    from module_b import helper\\n    return helper() + 1\", mod_a.__dict__)\n        exec(\"def helper():\\n    return 5\", mod_b.__dict__)\n        assert mod_a.get_value() == 6\n    finally:\n        sys.modules.clear()\n        sys.modules.update(modules)\n", "category": "stability_noop", "topic": "imports_modules", "starter_check": "pass"}
{"task_id": "bug_finalizer_49", "prompt": "Fix the __del__ method that resurrects the object causing eternal lifecycle.", "signature": "class Resource:", "starter_code": "class Resource:\n    _instances = set()\n    def __init__(self, name):\n        self.name = name\n        self._instances.add(self)\n    def __del__(self):\n        print(f\"Cleaning {self.name}\")\n        self._instances.add(self)  # Resurrection!\n", "tests": "def test_resource():\n    import gc\n    Resource._instances.clear()\n    r = Resource(\"test\")\n    del r\n    gc.collect()\n    gc.collect()\n    assert len(Resource._instances) == 0  # Should be empty, not resurrected\n", "category": "bugfix", "topic": "gc_weakref", "starter_check": "fail"}
{"task_id": "bug_gil_race_50", "prompt": "Fix the race condition in thread counter (not atomic). Result must be exactly 1000.", "signature": "import threading\ndef increment_counter(n: int) -> int:", "starter_code": "import threading\ndef increment_counter(n: int) -> int:\n    counter = 0\n    def worker():\n        nonlocal counter\n        for _ in range(n):\n            counter += 1\n    threads = [threading.Thread(target=worker) for _ in range(10)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    return counter\n", "tests": "def test_increment_counter():\n    result = increment_counter(100)\n    assert result == 1000, f\"Got {result}, expected 1000\"\n", "category": "stability_noop", "topic": "concurrency", "starter_check": "pass"}
