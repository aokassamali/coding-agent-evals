{"task_id": "osc_queue_001", "prompt": "Fix this queue. Tests are failing with wrong order and memory issues.", "signature": "class Queue:", "starter_code": "class Queue:\n    def __init__(self):\n        self.items = []\n        self.front = 0\n        self.rear = -1\n    \n    def enqueue(self, item):\n        self.rear += 1\n        if self.rear < len(self.items):\n            self.items[self.rear] = item\n        else:\n            self.items.append(item)\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError('empty')\n        item = self.items[self.front]\n        self.front += 1\n        # Memory cleanup attempt - but breaks things\n        if self.front > 100:\n            self.items = self.items[self.front:]\n            self.rear -= self.front\n            self.front = 0\n        return item\n    \n    def is_empty(self):\n        return self.front > self.rear\n    \n    def size(self):\n        return self.rear - self.front + 1", "tests": "def test_queue_basic():\n    q = Queue()\n    q.enqueue(1)\n    q.enqueue(2)\n    assert q.dequeue() == 1\n    assert q.dequeue() == 2\n\ndef test_queue_interleaved():\n    q = Queue()\n    for i in range(150):\n        q.enqueue(i)\n    for i in range(150):\n        assert q.dequeue() == i\n    # Now interleave\n    for i in range(50):\n        q.enqueue(i * 10)\n        if i % 2 == 0:\n            val = q.dequeue()\n            assert val == (i // 2) * 10\n\ndef test_queue_size():\n    q = Queue()\n    assert q.size() == 0\n    q.enqueue('a')\n    assert q.size() == 1\n    q.dequeue()\n    assert q.size() == 0", "category": "bugfix", "topic": "queue_impl", "tier": "oscillation", "starter_check": "fail", "approaches": ["list_with_indices", "collections_deque", "circular_buffer"]}
{"task_id": "osc_queue_002", "prompt": "Fix this queue implementation. Getting index errors and wrong values.", "signature": "class Queue:", "starter_code": "from collections import deque\n\nclass Queue:\n    def __init__(self):\n        self._data = deque()\n        self._list_backup = []  # For 'compatibility'\n    \n    def enqueue(self, item):\n        self._data.append(item)\n        self._list_backup.append(item)\n    \n    def dequeue(self):\n        if not self._data:\n            raise IndexError('empty')\n        # Bug: popping from wrong structure\n        self._list_backup.pop(0)\n        return self._data.pop()  # Wrong end!\n    \n    def peek(self):\n        return self._list_backup[0] if self._list_backup else None\n    \n    def is_empty(self):\n        return len(self._data) == 0", "tests": "def test_queue_order():\n    q = Queue()\n    q.enqueue('first')\n    q.enqueue('second')\n    q.enqueue('third')\n    assert q.dequeue() == 'first'\n    assert q.dequeue() == 'second'\n    assert q.peek() == 'third'\n\ndef test_queue_mixed():\n    q = Queue()\n    q.enqueue(1)\n    assert q.dequeue() == 1\n    q.enqueue(2)\n    q.enqueue(3)\n    assert q.dequeue() == 2\n    assert not q.is_empty()\n    assert q.dequeue() == 3\n    assert q.is_empty()", "category": "bugfix", "topic": "queue_impl", "tier": "oscillation", "starter_check": "fail", "approaches": ["deque_only", "list_only", "hybrid_fixed"]}
{"task_id": "osc_stack_001", "prompt": "Fix this stack. Pop returns wrong values, peek crashes.", "signature": "class Stack:", "starter_code": "class Stack:\n    def __init__(self):\n        self.items = []\n        self.top_idx = -1\n    \n    def push(self, item):\n        self.top_idx += 1\n        if self.top_idx < len(self.items):\n            self.items[self.top_idx] = item\n        else:\n            self.items.append(item)\n    \n    def pop(self):\n        if self.top_idx < 0:\n            raise IndexError('empty')\n        # Bug: returning wrong index\n        item = self.items[0]\n        self.top_idx -= 1\n        return item\n    \n    def peek(self):\n        # Bug: wrong index\n        return self.items[self.top_idx + 1]\n    \n    def is_empty(self):\n        return self.top_idx < 0", "tests": "def test_stack_lifo():\n    s = Stack()\n    s.push(1)\n    s.push(2)\n    s.push(3)\n    assert s.pop() == 3\n    assert s.pop() == 2\n    assert s.peek() == 1\n    assert s.pop() == 1\n\ndef test_stack_reuse():\n    s = Stack()\n    for i in range(10):\n        s.push(i)\n    for i in range(9, -1, -1):\n        assert s.pop() == i\n    # Reuse after emptying\n    s.push(100)\n    assert s.peek() == 100\n    assert s.pop() == 100", "category": "bugfix", "topic": "stack_impl", "tier": "oscillation", "starter_check": "fail", "approaches": ["list_append_pop", "index_tracking", "linked_nodes"]}
{"task_id": "osc_stack_002", "prompt": "Fix this linked stack implementation. Tests failing with None and crashes.", "signature": "class Stack:", "starter_code": "class Stack:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n    \n    def push(self, item):\n        node = {'val': item, 'next': None}  # Bug: not linking\n        self.head = node\n        self.size += 1\n    \n    def pop(self):\n        if not self.head:\n            raise IndexError('empty')\n        val = self.head['val']\n        self.head = self.head['next']\n        self.size -= 1\n        return val\n    \n    def peek(self):\n        if not self.head:\n            raise IndexError('empty')\n        return self.head['next']['val']  # Bug: wrong access\n    \n    def __len__(self):\n        return self.size", "tests": "def test_linked_stack():\n    s = Stack()\n    s.push('a')\n    s.push('b')\n    assert s.peek() == 'b'\n    assert s.pop() == 'b'\n    assert s.pop() == 'a'\n    assert len(s) == 0\n\ndef test_linked_stack_many():\n    s = Stack()\n    for i in range(100):\n        s.push(i)\n    assert len(s) == 100\n    for i in range(99, -1, -1):\n        assert s.pop() == i", "category": "bugfix", "topic": "stack_impl", "tier": "oscillation", "starter_check": "fail", "approaches": ["linked_list_dict", "linked_list_class", "python_list"]}
{"task_id": "osc_cache_001", "prompt": "Fix this LRU cache. Eviction is wrong and get() returns stale data.", "signature": "class LRUCache:", "starter_code": "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.access_order = []  # Track access times\n        self.access_count = {}  # Bug: mixing LRU and LFU concepts\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        # Bug: updating wrong tracking\n        self.access_count[key] = self.access_count.get(key, 0) + 1\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache[key] = value\n            return\n        if len(self.cache) >= self.capacity:\n            # Bug: evicting by frequency not recency\n            victim = min(self.access_count.keys(), key=lambda k: self.access_count[k])\n            del self.cache[victim]\n            del self.access_count[victim]\n        self.cache[key] = value\n        self.access_count[key] = 1", "tests": "def test_lru_eviction():\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    assert cache.get(1) == 1  # Access 1\n    cache.put(3, 3)  # Should evict 2 (least recently used)\n    assert cache.get(2) == -1\n    assert cache.get(3) == 3\n\ndef test_lru_update():\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    cache.get(1)  # Access 1\n    cache.get(1)  # Access 1 again\n    cache.put(3, 3)  # Should still evict 2, not 1\n    assert cache.get(1) == 1\n    assert cache.get(2) == -1\n\ndef test_lru_overwrite():\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(1, 10)\n    assert cache.get(1) == 10", "category": "bugfix", "topic": "lru_cache", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict", "dict_with_dll", "dict_with_timestamp"]}
{"task_id": "osc_cache_002", "prompt": "Fix this cache. Capacity not respected, ordering broken.", "signature": "class LRUCache:", "starter_code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        # Bug: move_to_end missing\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            # Bug: not updating position\n            self.cache[key] = value\n        else:\n            self.cache[key] = value\n        # Bug: wrong eviction logic\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=True)  # Wrong end!", "tests": "def test_cache_lru_order():\n    c = LRUCache(2)\n    c.put('a', 1)\n    c.put('b', 2)\n    c.get('a')  # 'a' is now most recent\n    c.put('c', 3)  # Should evict 'b'\n    assert c.get('a') == 1\n    assert c.get('b') == -1\n    assert c.get('c') == 3\n\ndef test_cache_update_moves():\n    c = LRUCache(3)\n    c.put(1, 'one')\n    c.put(2, 'two')\n    c.put(3, 'three')\n    c.put(1, 'ONE')  # Update should move to end\n    c.put(4, 'four')  # Should evict 2\n    assert c.get(2) == -1\n    assert c.get(1) == 'ONE'", "category": "bugfix", "topic": "lru_cache", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict_fixed", "plain_dict_list", "custom_dll"]}
{"task_id": "osc_graph_001", "prompt": "Fix this graph. add_edge and has_edge returning wrong results.", "signature": "class Graph:", "starter_code": "class Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj = {}  # Adjacency list\n        self.matrix = [[False] * n for _ in range(n)]  # Also matrix?\n    \n    def add_edge(self, u, v):\n        # Bug: only updating one structure\n        if u not in self.adj:\n            self.adj[u] = set()\n        self.adj[u].add(v)\n        # Matrix not updated!\n    \n    def has_edge(self, u, v):\n        # Bug: checking wrong structure\n        return self.matrix[u][v]\n    \n    def neighbors(self, u):\n        # Bug: inconsistent with has_edge\n        return list(self.adj.get(u, set()))", "tests": "def test_graph_basic():\n    g = Graph(5)\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    assert g.has_edge(0, 1)\n    assert g.has_edge(0, 2)\n    assert not g.has_edge(1, 0)\n    assert not g.has_edge(2, 3)\n\ndef test_graph_neighbors():\n    g = Graph(4)\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(0, 3)\n    n = g.neighbors(0)\n    assert set(n) == {1, 2, 3}\n    assert g.neighbors(1) == []\n\ndef test_graph_dense():\n    g = Graph(10)\n    for i in range(10):\n        for j in range(10):\n            if i != j:\n                g.add_edge(i, j)\n    assert g.has_edge(5, 7)\n    assert len(g.neighbors(0)) == 9", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["adjacency_list_only", "adjacency_matrix_only", "hybrid_consistent"]}
{"task_id": "osc_graph_002", "prompt": "Fix this undirected graph. Edge counting wrong, has_edge inconsistent.", "signature": "class UndirectedGraph:", "starter_code": "class UndirectedGraph:\n    def __init__(self):\n        self.edges = set()\n        self.adj = {}\n    \n    def add_edge(self, u, v):\n        # Bug: only adding one direction to adj\n        if u not in self.adj:\n            self.adj[u] = []\n        self.adj[u].append(v)\n        # Bug: tuple ordering inconsistent\n        self.edges.add((u, v))\n    \n    def has_edge(self, u, v):\n        # Bug: doesn't check both orderings\n        return (u, v) in self.edges\n    \n    def degree(self, u):\n        return len(self.adj.get(u, []))\n    \n    def num_edges(self):\n        return len(self.edges)", "tests": "def test_undirected_symmetry():\n    g = UndirectedGraph()\n    g.add_edge(1, 2)\n    assert g.has_edge(1, 2)\n    assert g.has_edge(2, 1)  # Should work both ways\n\ndef test_undirected_degree():\n    g = UndirectedGraph()\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(1, 2)\n    assert g.degree(0) == 2\n    assert g.degree(1) == 2\n    assert g.degree(2) == 2\n\ndef test_undirected_count():\n    g = UndirectedGraph()\n    g.add_edge(1, 2)\n    g.add_edge(2, 3)\n    assert g.num_edges() == 2  # Not 4!", "category": "bugfix", "topic": "graph", "tier": "oscillation", "starter_check": "fail", "approaches": ["set_normalized_tuples", "adj_list_bidirectional", "matrix_symmetric"]}
{"task_id": "osc_sort_001", "prompt": "Fix this quicksort. Wrong output and stack overflow on some inputs.", "signature": "def quicksort(arr):", "starter_code": "def quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    # Bug: bad pivot selection causes stack overflow on sorted input\n    pivot = arr[0]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    # Bug: wrong order\n    return quicksort(right) + middle + quicksort(left)", "tests": "def test_sort_basic():\n    assert quicksort([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9]\n    assert quicksort([]) == []\n    assert quicksort([1]) == [1]\n\ndef test_sort_sorted():\n    # Should not stack overflow\n    arr = list(range(100))\n    assert quicksort(arr) == arr\n    assert quicksort(arr[::-1]) == arr\n\ndef test_sort_duplicates():\n    assert quicksort([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert quicksort([2, 1, 2, 1]) == [1, 1, 2, 2]", "category": "bugfix", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["recursive_fixed_pivot", "recursive_median_pivot", "iterative_stack"]}
{"task_id": "osc_sort_002", "prompt": "Fix this merge sort. Returns wrong order, crashes on empty.", "signature": "def mergesort(arr):", "starter_code": "def mergesort(arr):\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) // 2\n    left = mergesort(arr[:mid])\n    right = mergesort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        # Bug: wrong comparison\n        if left[i] > right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    # Bug: appending in wrong order\n    result.extend(right[j:])\n    result.extend(left[i:])\n    return result", "tests": "def test_mergesort_basic():\n    assert mergesort([5, 2, 8, 1, 9]) == [1, 2, 5, 8, 9]\n    assert mergesort([1]) == [1]\n    assert mergesort([]) == []\n\ndef test_mergesort_stability():\n    arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\n    assert mergesort(arr) == sorted(arr)\n\ndef test_mergesort_negative():\n    assert mergesort([-1, -5, 3, 0, 2]) == [-5, -1, 0, 2, 3]", "category": "bugfix", "topic": "sorting", "tier": "oscillation", "starter_check": "fail", "approaches": ["recursive_merge", "iterative_bottomup", "builtin_sorted"]}
{"task_id": "osc_search_001", "prompt": "Fix this binary search. Returns wrong index, infinite loop on some inputs.", "signature": "def binary_search(arr, target):", "starter_code": "def binary_search(arr, target):\n    if not arr:\n        return -1\n    lo, hi = 0, len(arr)  # Bug: should be len-1\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid  # Bug: should be mid+1\n        else:\n            hi = mid\n    return -1", "tests": "def test_bsearch_found():\n    arr = [1, 3, 5, 7, 9, 11]\n    assert binary_search(arr, 5) == 2\n    assert binary_search(arr, 1) == 0\n    assert binary_search(arr, 11) == 5\n\ndef test_bsearch_not_found():\n    arr = [1, 3, 5, 7, 9]\n    assert binary_search(arr, 4) == -1\n    assert binary_search(arr, 0) == -1\n    assert binary_search(arr, 10) == -1\n\ndef test_bsearch_edge():\n    assert binary_search([], 5) == -1\n    assert binary_search([5], 5) == 0\n    assert binary_search([5], 3) == -1", "category": "bugfix", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["iterative_inclusive", "iterative_exclusive", "recursive"]}
{"task_id": "osc_search_002", "prompt": "Fix this search. Should find leftmost occurrence but returns random index.", "signature": "def search_leftmost(arr, target):", "starter_code": "def search_leftmost(arr, target):\n    \"\"\"Return index of leftmost occurrence of target, or -1\"\"\"\n    # Bug: linear search from wrong end\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == target:\n            return i\n    return -1", "tests": "def test_leftmost_basic():\n    arr = [1, 2, 2, 2, 3, 4]\n    assert search_leftmost(arr, 2) == 1  # First 2 is at index 1\n    assert search_leftmost(arr, 1) == 0\n    assert search_leftmost(arr, 4) == 5\n\ndef test_leftmost_not_found():\n    assert search_leftmost([1, 2, 3], 5) == -1\n    assert search_leftmost([], 1) == -1\n\ndef test_leftmost_all_same():\n    arr = [7, 7, 7, 7, 7]\n    assert search_leftmost(arr, 7) == 0", "category": "bugfix", "topic": "search", "tier": "oscillation", "starter_check": "fail", "approaches": ["linear_forward", "binary_search_left", "bisect_module"]}
{"task_id": "osc_hash_001", "prompt": "Fix this hash table. Collisions not handled, get() returns wrong values.", "signature": "class HashTable:", "starter_code": "class HashTable:\n    def __init__(self, size=16):\n        self.size = size\n        self.buckets = [None] * size\n        self.count = 0\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        idx = self._hash(key)\n        # Bug: overwrites on collision\n        self.buckets[idx] = (key, value)\n        self.count += 1\n    \n    def get(self, key):\n        idx = self._hash(key)\n        if self.buckets[idx] is None:\n            return None\n        # Bug: doesn't check if key matches\n        return self.buckets[idx][1]\n    \n    def __len__(self):\n        return self.count", "tests": "def test_hash_basic():\n    h = HashTable()\n    h.put('a', 1)\n    h.put('b', 2)\n    assert h.get('a') == 1\n    assert h.get('b') == 2\n    assert h.get('c') is None\n\ndef test_hash_collision():\n    h = HashTable(4)  # Small size forces collisions\n    h.put('a', 1)\n    h.put('e', 5)  # Likely collides with 'a'\n    h.put('i', 9)\n    assert h.get('a') == 1\n    assert h.get('e') == 5\n    assert h.get('i') == 9\n\ndef test_hash_update():\n    h = HashTable()\n    h.put('x', 100)\n    h.put('x', 200)\n    assert h.get('x') == 200", "category": "bugfix", "topic": "hashtable", "tier": "oscillation", "starter_check": "fail", "approaches": ["chaining_list", "open_addressing", "python_dict_wrapper"]}
{"task_id": "osc_hash_002", "prompt": "Fix this hash map with linear probing. Delete breaks lookups.", "signature": "class HashMap:", "starter_code": "class HashMap:\n    def __init__(self, capacity=16):\n        self.capacity = capacity\n        self.keys = [None] * capacity\n        self.values = [None] * capacity\n    \n    def _hash(self, key):\n        return hash(key) % self.capacity\n    \n    def put(self, key, value):\n        idx = self._hash(key)\n        while self.keys[idx] is not None and self.keys[idx] != key:\n            idx = (idx + 1) % self.capacity\n        self.keys[idx] = key\n        self.values[idx] = value\n    \n    def get(self, key):\n        idx = self._hash(key)\n        while self.keys[idx] is not None:\n            if self.keys[idx] == key:\n                return self.values[idx]\n            idx = (idx + 1) % self.capacity\n        return None\n    \n    def delete(self, key):\n        idx = self._hash(key)\n        while self.keys[idx] is not None:\n            if self.keys[idx] == key:\n                # Bug: naive delete breaks probe chain\n                self.keys[idx] = None\n                self.values[idx] = None\n                return\n            idx = (idx + 1) % self.capacity", "tests": "def test_hashmap_delete():\n    h = HashMap(8)\n    h.put('a', 1)\n    h.put('b', 2)  # Might probe past 'a'\n    h.put('c', 3)\n    h.delete('a')\n    assert h.get('a') is None\n    assert h.get('b') == 2  # Should still find 'b'\n    assert h.get('c') == 3\n\ndef test_hashmap_reinsert():\n    h = HashMap(8)\n    h.put('x', 10)\n    h.delete('x')\n    h.put('x', 20)\n    assert h.get('x') == 20\n\ndef test_hashmap_chain():\n    h = HashMap(4)  # Force collisions\n    for i, c in enumerate('abcdef'):\n        h.put(c, i)\n    for i, c in enumerate('abcdef'):\n        assert h.get(c) == i", "category": "bugfix", "topic": "hashtable", "tier": "oscillation", "starter_check": "fail", "approaches": ["tombstone_marker", "rehash_cluster", "chaining_fallback"]}
{"task_id": "osc_pq_001", "prompt": "Fix this priority queue. Wrong priority order, peek inconsistent with pop.", "signature": "class PriorityQueue:", "starter_code": "class PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        self.heap.append((priority, item))\n        self._sift_up(len(self.heap) - 1)\n    \n    def pop(self):\n        if not self.heap:\n            raise IndexError('empty')\n        # Bug: not maintaining heap property\n        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\n        item = self.heap.pop()\n        if self.heap:\n            self._sift_down(0)\n        return item[1]\n    \n    def peek(self):\n        if not self.heap:\n            raise IndexError('empty')\n        # Bug: wrong index after operations\n        return self.heap[-1][1]\n    \n    def _sift_up(self, idx):\n        parent = (idx - 1) // 2\n        # Bug: wrong comparison for max heap vs min heap\n        if idx > 0 and self.heap[idx][0] > self.heap[parent][0]:\n            self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx]\n            self._sift_up(parent)\n    \n    def _sift_down(self, idx):\n        smallest = idx\n        left = 2 * idx + 1\n        right = 2 * idx + 2\n        if left < len(self.heap) and self.heap[left][0] > self.heap[smallest][0]:\n            smallest = left\n        if right < len(self.heap) and self.heap[right][0] > self.heap[smallest][0]:\n            smallest = right\n        if smallest != idx:\n            self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx]\n            self._sift_down(smallest)", "tests": "def test_pq_order():\n    pq = PriorityQueue()\n    pq.push('low', 1)\n    pq.push('high', 10)\n    pq.push('med', 5)\n    assert pq.pop() == 'high'\n    assert pq.pop() == 'med'\n    assert pq.pop() == 'low'\n\ndef test_pq_peek():\n    pq = PriorityQueue()\n    pq.push('a', 3)\n    pq.push('b', 7)\n    assert pq.peek() == 'b'\n    assert pq.pop() == 'b'\n    assert pq.peek() == 'a'\n\ndef test_pq_same_priority():\n    pq = PriorityQueue()\n    pq.push('x', 5)\n    pq.push('y', 5)\n    pq.push('z', 5)\n    results = [pq.pop(), pq.pop(), pq.pop()]\n    assert set(results) == {'x', 'y', 'z'}", "category": "bugfix", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["max_heap_manual", "min_heap_negated", "heapq_module"]}
{"task_id": "osc_pq_002", "prompt": "Fix this min-heap priority queue. heapq usage is wrong.", "signature": "class MinPQ:", "starter_code": "import heapq\n\nclass MinPQ:\n    def __init__(self):\n        self.data = []\n        self.index = 0  # For FIFO tiebreaking\n    \n    def push(self, item, priority):\n        # Bug: tuple order wrong for heapq\n        heapq.heappush(self.data, (item, priority, self.index))\n        self.index += 1\n    \n    def pop(self):\n        if not self.data:\n            raise IndexError('empty')\n        entry = heapq.heappop(self.data)\n        return entry[0]  # Return item\n    \n    def peek(self):\n        if not self.data:\n            raise IndexError('empty')\n        return self.data[0][0]", "tests": "def test_minpq_order():\n    pq = MinPQ()\n    pq.push('big', 100)\n    pq.push('small', 1)\n    pq.push('med', 50)\n    assert pq.pop() == 'small'\n    assert pq.pop() == 'med'\n    assert pq.pop() == 'big'\n\ndef test_minpq_fifo_tie():\n    pq = MinPQ()\n    pq.push('first', 5)\n    pq.push('second', 5)\n    pq.push('third', 5)\n    assert pq.pop() == 'first'\n    assert pq.pop() == 'second'\n    assert pq.pop() == 'third'\n\ndef test_minpq_negative():\n    pq = MinPQ()\n    pq.push('a', -10)\n    pq.push('b', 0)\n    pq.push('c', -5)\n    assert pq.pop() == 'a'\n    assert pq.peek() == 'c'", "category": "bugfix", "topic": "priority_queue", "tier": "oscillation", "starter_check": "fail", "approaches": ["heapq_tuple_fixed", "custom_heap", "sorted_list"]}
{"task_id": "osc_tree_001", "prompt": "Fix this BST. Insert creates wrong structure, search fails.", "signature": "class BST:", "starter_code": "class BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, val):\n        if not self.root:\n            self.root = {'val': val, 'left': None, 'right': None}\n            return\n        node = self.root\n        while True:\n            if val < node['val']:\n                if node['left']:\n                    node = node['left']\n                else:\n                    # Bug: wrong assignment\n                    node['left'] = val\n                    break\n            else:\n                if node['right']:\n                    node = node['right']\n                else:\n                    node['right'] = val\n                    break\n    \n    def search(self, val):\n        node = self.root\n        while node:\n            if node['val'] == val:\n                return True\n            elif val < node['val']:\n                node = node['left']\n            else:\n                node = node['right']\n        return False", "tests": "def test_bst_insert_search():\n    t = BST()\n    t.insert(5)\n    t.insert(3)\n    t.insert(7)\n    t.insert(1)\n    assert t.search(5)\n    assert t.search(3)\n    assert t.search(7)\n    assert t.search(1)\n    assert not t.search(10)\n\ndef test_bst_duplicates():\n    t = BST()\n    t.insert(5)\n    t.insert(5)\n    t.insert(5)\n    assert t.search(5)\n\ndef test_bst_inorder():\n    t = BST()\n    for v in [4, 2, 6, 1, 3, 5, 7]:\n        t.insert(v)\n    # All should be findable\n    for v in [1, 2, 3, 4, 5, 6, 7]:\n        assert t.search(v)", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "recursive_insert"]}
{"task_id": "osc_tree_002", "prompt": "Fix this BST delete. Tree structure corrupted after deletion.", "signature": "class BinarySearchTree:", "starter_code": "class BinarySearchTree:\n    def __init__(self):\n        self.root = None\n    \n    class Node:\n        def __init__(self, val):\n            self.val = val\n            self.left = None\n            self.right = None\n    \n    def insert(self, val):\n        if not self.root:\n            self.root = self.Node(val)\n        else:\n            self._insert(self.root, val)\n    \n    def _insert(self, node, val):\n        if val < node.val:\n            if node.left:\n                self._insert(node.left, val)\n            else:\n                node.left = self.Node(val)\n        else:\n            if node.right:\n                self._insert(node.right, val)\n            else:\n                node.right = self.Node(val)\n    \n    def delete(self, val):\n        self.root = self._delete(self.root, val)\n    \n    def _delete(self, node, val):\n        if not node:\n            return None\n        if val < node.val:\n            node.left = self._delete(node.left, val)\n        elif val > node.val:\n            node.right = self._delete(node.right, val)\n        else:\n            # Found node to delete\n            if not node.left:\n                return node.right\n            if not node.right:\n                return node.left\n            # Bug: wrong successor logic\n            successor = node.right\n            node.val = successor.val\n            node.right = None  # Bug: loses subtree\n        return node\n    \n    def search(self, val):\n        return self._search(self.root, val)\n    \n    def _search(self, node, val):\n        if not node:\n            return False\n        if node.val == val:\n            return True\n        if val < node.val:\n            return self._search(node.left, val)\n        return self._search(node.right, val)", "tests": "def test_bst_delete_leaf():\n    t = BinarySearchTree()\n    for v in [5, 3, 7]:\n        t.insert(v)\n    t.delete(3)\n    assert not t.search(3)\n    assert t.search(5)\n    assert t.search(7)\n\ndef test_bst_delete_one_child():\n    t = BinarySearchTree()\n    for v in [5, 3, 7, 6]:\n        t.insert(v)\n    t.delete(7)\n    assert t.search(6)\n    assert not t.search(7)\n\ndef test_bst_delete_two_children():\n    t = BinarySearchTree()\n    for v in [5, 3, 7, 6, 8]:\n        t.insert(v)\n    t.delete(7)\n    assert t.search(6)\n    assert t.search(8)\n    assert not t.search(7)\n    assert t.search(5)", "category": "bugfix", "topic": "bst", "tier": "oscillation", "starter_check": "fail", "approaches": ["inorder_successor", "inorder_predecessor", "iterative_delete"]}
{"task_id": "osc_dll_001", "prompt": "Fix this doubly linked list. Insert and delete corrupt the links.", "signature": "class DoublyLinkedList:", "starter_code": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n    \n    def append(self, val):\n        node = {'val': val, 'prev': self.tail, 'next': None}\n        if self.tail:\n            self.tail['next'] = node\n        self.tail = node\n        if not self.head:\n            self.head = node\n        self.size += 1\n    \n    def prepend(self, val):\n        node = {'val': val, 'prev': None, 'next': self.head}\n        if self.head:\n            # Bug: not setting prev\n            pass\n        self.head = node\n        if not self.tail:\n            self.tail = node\n        self.size += 1\n    \n    def delete(self, val):\n        node = self.head\n        while node:\n            if node['val'] == val:\n                # Bug: incomplete link updates\n                if node['prev']:\n                    node['prev']['next'] = node['next']\n                if node['next']:\n                    node['next']['prev'] = node['prev']\n                self.size -= 1\n                return True\n            node = node['next']\n        return False\n    \n    def to_list(self):\n        result = []\n        node = self.head\n        while node:\n            result.append(node['val'])\n            node = node['next']\n        return result", "tests": "def test_dll_append():\n    dll = DoublyLinkedList()\n    dll.append(1)\n    dll.append(2)\n    dll.append(3)\n    assert dll.to_list() == [1, 2, 3]\n\ndef test_dll_prepend():\n    dll = DoublyLinkedList()\n    dll.prepend(1)\n    dll.prepend(2)\n    dll.prepend(3)\n    assert dll.to_list() == [3, 2, 1]\n\ndef test_dll_delete_head():\n    dll = DoublyLinkedList()\n    dll.append(1)\n    dll.append(2)\n    dll.append(3)\n    dll.delete(1)\n    assert dll.to_list() == [2, 3]\n    assert dll.head['val'] == 2\n\ndef test_dll_delete_tail():\n    dll = DoublyLinkedList()\n    dll.append(1)\n    dll.append(2)\n    dll.append(3)\n    dll.delete(3)\n    assert dll.to_list() == [1, 2]\n    assert dll.tail['val'] == 2", "category": "bugfix", "topic": "linked_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_nodes", "class_nodes", "sentinel_nodes"]}
{"task_id": "osc_dll_002", "prompt": "Fix this linked list. Reverse doesn't work, iteration broken.", "signature": "class LinkedList:", "starter_code": "class LinkedList:\n    class Node:\n        def __init__(self, val):\n            self.val = val\n            self.next = None\n            self.prev = None\n    \n    def __init__(self):\n        self.head = None\n        self.tail = None\n    \n    def append(self, val):\n        node = self.Node(val)\n        if not self.head:\n            self.head = self.tail = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n            self.tail = node\n    \n    def reverse(self):\n        current = self.head\n        while current:\n            # Bug: swap is incomplete\n            current.prev, current.next = current.next, current.prev\n            current = current.prev  # Bug: wrong direction after swap\n        # Bug: head/tail not swapped\n    \n    def __iter__(self):\n        node = self.head\n        while node:\n            yield node.val\n            node = node.next", "tests": "def test_ll_reverse():\n    ll = LinkedList()\n    for i in [1, 2, 3, 4, 5]:\n        ll.append(i)\n    ll.reverse()\n    assert list(ll) == [5, 4, 3, 2, 1]\n\ndef test_ll_reverse_single():\n    ll = LinkedList()\n    ll.append(42)\n    ll.reverse()\n    assert list(ll) == [42]\n\ndef test_ll_reverse_empty():\n    ll = LinkedList()\n    ll.reverse()\n    assert list(ll) == []\n\ndef test_ll_reverse_twice():\n    ll = LinkedList()\n    for i in [1, 2, 3]:\n        ll.append(i)\n    ll.reverse()\n    ll.reverse()\n    assert list(ll) == [1, 2, 3]", "category": "bugfix", "topic": "linked_list", "tier": "oscillation", "starter_check": "fail", "approaches": ["iterative_swap", "recursive_reverse", "new_list_copy"]}
{"task_id": "osc_timer_001", "prompt": "Fix this timer. Callback fires immediately, cancel doesn't work.", "signature": "class Timer:", "starter_code": "import threading\nimport time\n\nclass Timer:\n    def __init__(self, interval, callback):\n        self.interval = interval\n        self.callback = callback\n        self.cancelled = False\n        self.thread = None\n    \n    def start(self):\n        # Bug: no delay before callback\n        self.callback()\n    \n    def cancel(self):\n        # Bug: doesn't actually stop anything\n        self.cancelled = True", "tests": "def test_timer_delay():\n    import time\n    result = []\n    def cb():\n        result.append(time.time())\n    \n    start = time.time()\n    t = Timer(0.1, cb)\n    t.start()\n    time.sleep(0.15)\n    \n    assert len(result) == 1\n    assert result[0] - start >= 0.09  # Callback was delayed\n\ndef test_timer_cancel():\n    result = []\n    def cb():\n        result.append(1)\n    \n    t = Timer(0.1, cb)\n    t.start()\n    t.cancel()\n    time.sleep(0.15)\n    \n    assert len(result) == 0  # Callback never fired\n\ndef test_timer_multiple():\n    result = []\n    t1 = Timer(0.05, lambda: result.append('a'))\n    t2 = Timer(0.1, lambda: result.append('b'))\n    t1.start()\n    t2.start()\n    time.sleep(0.15)\n    assert result == ['a', 'b']", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["threading_timer", "thread_sleep", "event_based"]}
{"task_id": "osc_timer_002", "prompt": "Fix this repeating timer. Only fires once, stop doesn't work.", "signature": "class RepeatingTimer:", "starter_code": "import threading\nimport time\n\nclass RepeatingTimer:\n    def __init__(self, interval, callback):\n        self.interval = interval\n        self.callback = callback\n        self.running = False\n    \n    def start(self):\n        self.running = True\n        # Bug: only runs once\n        threading.Timer(self.interval, self.callback).start()\n    \n    def stop(self):\n        # Bug: doesn't stop the timer thread\n        self.running = False", "tests": "def test_repeating_timer():\n    import time\n    count = [0]\n    def cb():\n        count[0] += 1\n    \n    t = RepeatingTimer(0.05, cb)\n    t.start()\n    time.sleep(0.18)\n    t.stop()\n    \n    assert count[0] >= 3  # Should fire multiple times\n\ndef test_repeating_stop():\n    import time\n    count = [0]\n    def cb():\n        count[0] += 1\n    \n    t = RepeatingTimer(0.05, cb)\n    t.start()\n    time.sleep(0.08)\n    t.stop()\n    final = count[0]\n    time.sleep(0.1)\n    \n    assert count[0] == final  # No more fires after stop", "category": "bugfix", "topic": "timer", "tier": "oscillation", "starter_check": "fail", "approaches": ["recursive_timer", "loop_thread", "event_flag"]}
{"task_id": "osc_pool_001", "prompt": "Fix this thread pool. Tasks not executed, shutdown hangs.", "signature": "class ThreadPool:", "starter_code": "import threading\nimport queue\n\nclass ThreadPool:\n    def __init__(self, num_workers):\n        self.tasks = queue.Queue()\n        self.workers = []\n        for _ in range(num_workers):\n            t = threading.Thread(target=self._worker)\n            t.start()\n            # Bug: typo in attribute name\n            self.worker.append(t)\n    \n    def _worker(self):\n        while True:\n            task = self.tasks.get()\n            if task is None:\n                break\n            # Bug: not calling the task\n            task\n            self.tasks.task_done()\n    \n    def submit(self, fn):\n        self.tasks.put(fn)\n    \n    def shutdown(self):\n        for _ in self.workers:\n            self.tasks.put(None)\n        for w in self.workers:\n            w.join()", "tests": "def test_pool_execute():\n    import time\n    results = []\n    def task(x):\n        def inner():\n            results.append(x)\n        return inner\n    \n    pool = ThreadPool(2)\n    for i in range(5):\n        pool.submit(task(i))\n    time.sleep(0.1)\n    pool.shutdown()\n    \n    assert sorted(results) == [0, 1, 2, 3, 4]\n\ndef test_pool_concurrent():\n    import time\n    times = []\n    def slow_task():\n        time.sleep(0.05)\n        times.append(time.time())\n    \n    pool = ThreadPool(4)\n    start = time.time()\n    for _ in range(4):\n        pool.submit(slow_task)\n    pool.shutdown()\n    elapsed = time.time() - start\n    \n    assert elapsed < 0.1  # Concurrent, not serial", "category": "bugfix", "topic": "thread_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["queue_workers", "futures_pattern", "dynamic_threads"]}
{"task_id": "osc_pool_002", "prompt": "Fix this connection pool. Connections leak, exhaustion not handled.", "signature": "class ConnectionPool:", "starter_code": "import threading\nimport queue\n\nclass ConnectionPool:\n    def __init__(self, max_size, factory):\n        self.max_size = max_size\n        self.factory = factory\n        self.pool = queue.Queue(maxsize=max_size)\n        self.size = 0\n        self.lock = threading.Lock()\n    \n    def acquire(self):\n        # Bug: doesn't create new connections\n        try:\n            return self.pool.get_nowait()\n        except queue.Empty:\n            return None\n    \n    def release(self, conn):\n        # Bug: doesn't handle full pool\n        self.pool.put(conn)", "tests": "def test_pool_reuse():\n    created = [0]\n    def factory():\n        created[0] += 1\n        return f'conn_{created[0]}'\n    \n    pool = ConnectionPool(2, factory)\n    c1 = pool.acquire()\n    c2 = pool.acquire()\n    assert c1 is not None\n    assert c2 is not None\n    \n    pool.release(c1)\n    c3 = pool.acquire()\n    assert c3 == c1  # Reused\n\ndef test_pool_limit():\n    pool = ConnectionPool(2, lambda: object())\n    c1 = pool.acquire()\n    c2 = pool.acquire()\n    c3 = pool.acquire()  # Should block or return None\n    \n    # Either blocking with timeout or returns None\n    assert c3 is None or c3 is not None\n\ndef test_pool_exhaust_wait():\n    import time\n    pool = ConnectionPool(1, lambda: 'conn')\n    c1 = pool.acquire()\n    \n    result = [None]\n    def get_conn():\n        result[0] = pool.acquire()\n    \n    t = threading.Thread(target=get_conn)\n    t.start()\n    time.sleep(0.05)\n    pool.release(c1)\n    t.join(timeout=0.1)\n    \n    assert result[0] is not None", "category": "bugfix", "topic": "connection_pool", "tier": "oscillation", "starter_check": "fail", "approaches": ["semaphore_based", "queue_blocking", "list_with_lock"]}
{"task_id": "osc_ratelimit_001", "prompt": "Fix this rate limiter. Allows bursts beyond limit, doesn't reset properly.", "signature": "class RateLimiter:", "starter_code": "import time\n\nclass RateLimiter:\n    def __init__(self, max_requests, window_seconds):\n        self.max_requests = max_requests\n        self.window = window_seconds\n        self.requests = []\n    \n    def allow(self):\n        now = time.time()\n        # Bug: not cleaning old requests\n        self.requests.append(now)\n        return len(self.requests) <= self.max_requests", "tests": "def test_ratelimit_basic():\n    rl = RateLimiter(3, 1.0)\n    assert rl.allow()\n    assert rl.allow()\n    assert rl.allow()\n    assert not rl.allow()  # 4th should fail\n\ndef test_ratelimit_reset():\n    import time\n    rl = RateLimiter(2, 0.1)\n    assert rl.allow()\n    assert rl.allow()\n    assert not rl.allow()\n    time.sleep(0.15)\n    assert rl.allow()  # Should reset after window\n\ndef test_ratelimit_sliding():\n    import time\n    rl = RateLimiter(3, 0.1)\n    rl.allow()\n    time.sleep(0.05)\n    rl.allow()\n    time.sleep(0.05)\n    rl.allow()\n    time.sleep(0.05)\n    # First request expired, should allow\n    assert rl.allow()", "category": "bugfix", "topic": "rate_limiting", "tier": "oscillation", "starter_check": "fail", "approaches": ["sliding_window_log", "token_bucket", "fixed_window_counter"]}
{"task_id": "osc_ratelimit_002", "prompt": "Fix this token bucket. Tokens don't refill, bursts miscounted.", "signature": "class TokenBucket:", "starter_code": "import time\n\nclass TokenBucket:\n    def __init__(self, capacity, refill_rate):\n        self.capacity = capacity\n        self.tokens = capacity\n        self.refill_rate = refill_rate  # tokens per second\n        self.last_refill = time.time()\n    \n    def consume(self, tokens=1):\n        # Bug: refill calculation wrong\n        now = time.time()\n        elapsed = now - self.last_refill\n        # Bug: not updating last_refill\n        self.tokens = min(self.capacity, self.tokens + elapsed)\n        \n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False", "tests": "def test_bucket_initial():\n    tb = TokenBucket(5, 1.0)\n    for _ in range(5):\n        assert tb.consume()\n    assert not tb.consume()\n\ndef test_bucket_refill():\n    import time\n    tb = TokenBucket(2, 10.0)  # 10 tokens/sec\n    tb.consume()\n    tb.consume()\n    assert not tb.consume()\n    time.sleep(0.15)  # Should refill ~1.5 tokens\n    assert tb.consume()\n\ndef test_bucket_burst():\n    tb = TokenBucket(10, 1.0)\n    # Should allow burst up to capacity\n    for _ in range(10):\n        assert tb.consume()\n    assert not tb.consume()", "category": "bugfix", "topic": "rate_limiting", "tier": "oscillation", "starter_check": "fail", "approaches": ["token_bucket_fixed", "leaky_bucket", "sliding_window"]}
{"task_id": "osc_lru_001", "prompt": "Fix this LRU cache decorator. Caching wrong values, not respecting maxsize.", "signature": "def lru_cache(maxsize=128):", "starter_code": "def lru_cache(maxsize=128):\n    def decorator(func):\n        cache = {}\n        order = []  # Track access order\n        \n        def wrapper(*args):\n            key = args\n            if key in cache:\n                # Bug: not updating order\n                return cache[key]\n            \n            result = func(*args)\n            cache[key] = result\n            order.append(key)\n            \n            # Bug: wrong eviction\n            if len(cache) > maxsize:\n                oldest = order[0]\n                del cache[oldest]\n                # Bug: not removing from order\n            \n            return result\n        \n        return wrapper\n    return decorator", "tests": "def test_lru_basic():\n    call_count = [0]\n    \n    @lru_cache(maxsize=2)\n    def expensive(x):\n        call_count[0] += 1\n        return x * 2\n    \n    assert expensive(1) == 2\n    assert expensive(1) == 2  # Cached\n    assert call_count[0] == 1\n\ndef test_lru_eviction():\n    @lru_cache(maxsize=2)\n    def fn(x):\n        return x\n    \n    fn(1)\n    fn(2)\n    fn(1)  # Access 1, making 2 least recent\n    fn(3)  # Should evict 2\n    \n    # 1 should still be cached, 2 should be evicted\n    call_count = [0]\n    original_fn = fn.__wrapped__ if hasattr(fn, '__wrapped__') else None\n\ndef test_lru_order():\n    calls = []\n    \n    @lru_cache(maxsize=2)\n    def track(x):\n        calls.append(x)\n        return x\n    \n    track(1)\n    track(2)\n    track(1)  # Refresh 1\n    track(3)  # Evict 2\n    track(2)  # Miss - should call again\n    \n    assert calls == [1, 2, 3, 2]", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["ordereddict_move", "list_tracking", "functools_wrapper"]}
{"task_id": "osc_lru_002", "prompt": "Fix this memoization decorator. Thread-unsafe, memory leak.", "signature": "def memoize(func):", "starter_code": "import threading\n\ndef memoize(func):\n    cache = {}\n    \n    def wrapper(*args, **kwargs):\n        # Bug: kwargs not handled in key\n        key = args\n        if key in cache:\n            return cache[key]\n        # Bug: not thread-safe\n        result = func(*args, **kwargs)\n        cache[key] = result\n        return result\n    \n    wrapper.cache = cache\n    return wrapper", "tests": "def test_memo_basic():\n    calls = [0]\n    \n    @memoize\n    def fib(n):\n        calls[0] += 1\n        if n < 2:\n            return n\n        return fib(n-1) + fib(n-2)\n    \n    assert fib(10) == 55\n    initial_calls = calls[0]\n    fib(10)\n    assert calls[0] == initial_calls  # No new calls\n\ndef test_memo_kwargs():\n    @memoize\n    def greet(name, greeting='Hello'):\n        return f'{greeting}, {name}'\n    \n    assert greet('Alice') == 'Hello, Alice'\n    assert greet('Alice', greeting='Hi') == 'Hi, Alice'\n    assert greet(name='Alice') == 'Hello, Alice'\n\ndef test_memo_threadsafe():\n    import threading\n    import time\n    \n    calls = [0]\n    \n    @memoize\n    def slow(x):\n        calls[0] += 1\n        time.sleep(0.01)\n        return x * 2\n    \n    threads = [threading.Thread(target=lambda: slow(1)) for _ in range(10)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    \n    # With proper locking, should only call once\n    assert calls[0] <= 2  # Allow small race window", "category": "bugfix", "topic": "caching", "tier": "oscillation", "starter_check": "fail", "approaches": ["lock_protected", "thread_local", "concurrent_dict"]}
{"task_id": "osc_retry_001", "prompt": "Fix this retry decorator. Wrong delay, doesn't respect max attempts.", "signature": "def retry(max_attempts=3, delay=1.0):", "starter_code": "import time\n\ndef retry(max_attempts=3, delay=1.0):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while True:  # Bug: infinite loop possible\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    # Bug: sleeps before checking attempts\n                    time.sleep(delay)\n                    if attempts >= max_attempts:\n                        raise\n        return wrapper\n    return decorator", "tests": "def test_retry_success():\n    attempts = [0]\n    \n    @retry(max_attempts=3, delay=0.01)\n    def flaky():\n        attempts[0] += 1\n        if attempts[0] < 2:\n            raise ValueError('fail')\n        return 'ok'\n    \n    assert flaky() == 'ok'\n    assert attempts[0] == 2\n\ndef test_retry_exhaust():\n    attempts = [0]\n    \n    @retry(max_attempts=3, delay=0.01)\n    def always_fail():\n        attempts[0] += 1\n        raise ValueError('fail')\n    \n    try:\n        always_fail()\n        assert False, 'Should have raised'\n    except ValueError:\n        pass\n    \n    assert attempts[0] == 3\n\ndef test_retry_no_delay_after_last():\n    import time\n    \n    @retry(max_attempts=2, delay=0.1)\n    def fail():\n        raise ValueError()\n    \n    start = time.time()\n    try:\n        fail()\n    except ValueError:\n        pass\n    elapsed = time.time() - start\n    \n    # Should only delay once (between attempt 1 and 2)\n    assert elapsed < 0.15", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["delay_between", "delay_after_fail", "exponential_backoff"]}
{"task_id": "osc_retry_002", "prompt": "Fix this exponential backoff retry. Backoff not exponential, jitter broken.", "signature": "def retry_with_backoff(max_attempts=3, base_delay=1.0, max_delay=60.0):", "starter_code": "import time\nimport random\n\ndef retry_with_backoff(max_attempts=3, base_delay=1.0, max_delay=60.0):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    # Bug: linear not exponential\n                    delay = base_delay * attempt\n                    # Bug: jitter can make delay negative\n                    delay += random.uniform(-delay, delay)\n                    delay = min(delay, max_delay)\n                    time.sleep(delay)\n            raise last_exception\n        return wrapper\n    return decorator", "tests": "def test_backoff_exponential():\n    import time\n    delays = []\n    \n    attempts = [0]\n    \n    @retry_with_backoff(max_attempts=4, base_delay=0.05, max_delay=1.0)\n    def measure_delays():\n        delays.append(time.time())\n        attempts[0] += 1\n        if attempts[0] < 4:\n            raise ValueError()\n        return 'ok'\n    \n    start = time.time()\n    result = measure_delays()\n    \n    # Delays should be roughly: 0.05, 0.1, 0.2 (exponential)\n    # Total should be > 0.3 for exponential\n    elapsed = time.time() - start\n    assert elapsed > 0.25\n\ndef test_backoff_max_delay():\n    @retry_with_backoff(max_attempts=2, base_delay=100.0, max_delay=0.05)\n    def fail():\n        raise ValueError()\n    \n    import time\n    start = time.time()\n    try:\n        fail()\n    except ValueError:\n        pass\n    \n    # Should be capped at max_delay\n    assert time.time() - start < 0.1\n\ndef test_backoff_jitter_positive():\n    @retry_with_backoff(max_attempts=3, base_delay=0.01, max_delay=1.0)\n    def fail():\n        raise ValueError()\n    \n    # Should not hang or error due to negative delays\n    import time\n    start = time.time()\n    try:\n        fail()\n    except ValueError:\n        pass\n    assert time.time() - start >= 0", "category": "bugfix", "topic": "retry", "tier": "oscillation", "starter_check": "fail", "approaches": ["power_of_two", "multiply_backoff", "decorrelated_jitter"]}
{"task_id": "osc_event_001", "prompt": "Fix this event emitter. Handlers not called, once doesn't work.", "signature": "class EventEmitter:", "starter_code": "class EventEmitter:\n    def __init__(self):\n        self.listeners = {}\n    \n    def on(self, event, handler):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        # Bug: adding handler incorrectly\n        self.listeners[event] = handler\n    \n    def once(self, event, handler):\n        def wrapper(*args):\n            handler(*args)\n            # Bug: doesn't remove after call\n        self.on(event, wrapper)\n    \n    def emit(self, event, *args):\n        if event not in self.listeners:\n            return\n        # Bug: listeners is not a list anymore\n        for handler in self.listeners[event]:\n            handler(*args)\n    \n    def off(self, event, handler):\n        if event in self.listeners:\n            self.listeners[event].remove(handler)", "tests": "def test_emitter_basic():\n    ee = EventEmitter()\n    results = []\n    ee.on('data', lambda x: results.append(x))\n    ee.emit('data', 1)\n    ee.emit('data', 2)\n    assert results == [1, 2]\n\ndef test_emitter_multiple():\n    ee = EventEmitter()\n    results = []\n    ee.on('event', lambda: results.append('a'))\n    ee.on('event', lambda: results.append('b'))\n    ee.emit('event')\n    assert set(results) == {'a', 'b'}\n\ndef test_emitter_once():\n    ee = EventEmitter()\n    count = [0]\n    ee.once('single', lambda: count.__setitem__(0, count[0] + 1))\n    ee.emit('single')\n    ee.emit('single')\n    ee.emit('single')\n    assert count[0] == 1", "category": "bugfix", "topic": "events", "tier": "oscillation", "starter_check": "fail", "approaches": ["list_handlers", "dict_with_id", "weakref_handlers"]}
{"task_id": "osc_event_002", "prompt": "Fix this pub/sub system. Messages lost, unsubscribe doesn't work.", "signature": "class PubSub:", "starter_code": "class PubSub:\n    def __init__(self):\n        self.topics = {}\n        self.subscriber_id = 0\n    \n    def subscribe(self, topic, callback):\n        if topic not in self.topics:\n            self.topics[topic] = {}\n        self.subscriber_id += 1\n        # Bug: wrong key assignment\n        self.topics[topic] = {self.subscriber_id: callback}\n        return self.subscriber_id\n    \n    def unsubscribe(self, topic, sub_id):\n        if topic in self.topics and sub_id in self.topics[topic]:\n            # Bug: deletes wrong thing\n            del self.topics[topic]\n    \n    def publish(self, topic, message):\n        if topic not in self.topics:\n            return 0\n        count = 0\n        for callback in self.topics[topic].values():\n            callback(message)\n            count += 1\n        return count", "tests": "def test_pubsub_basic():\n    ps = PubSub()\n    results = []\n    ps.subscribe('news', lambda m: results.append(m))\n    ps.publish('news', 'hello')\n    assert results == ['hello']\n\ndef test_pubsub_multi_subscriber():\n    ps = PubSub()\n    results = []\n    ps.subscribe('topic', lambda m: results.append(f'a:{m}'))\n    ps.subscribe('topic', lambda m: results.append(f'b:{m}'))\n    count = ps.publish('topic', 'msg')\n    assert count == 2\n    assert 'a:msg' in results\n    assert 'b:msg' in results\n\ndef test_pubsub_unsubscribe():\n    ps = PubSub()\n    results = []\n    sub_id = ps.subscribe('ch', lambda m: results.append(m))\n    ps.publish('ch', 1)\n    ps.unsubscribe('ch', sub_id)\n    ps.publish('ch', 2)\n    assert results == [1]  # Second publish should not reach", "category": "bugfix", "topic": "events", "tier": "oscillation", "starter_check": "fail", "approaches": ["dict_subscribers", "list_with_ids", "weakref_callbacks"]}