{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_723cbe4a4521", "task_id": "v11_osc_heap_006", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 1}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_5de4cc680ca6", "task_id": "v11_osc_heap_008", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 2}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_f4a9433f43a2", "task_id": "v11_osc_interval_merge_007", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 3}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_06bfa745471a", "task_id": "v11_osc_interval_merge_012", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 4}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_3b1f6ce5a3ba", "task_id": "v11_osc_heap_001", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 5}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_b565d7ad4981", "task_id": "v11_osc_sort_015", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 6}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_d847d362d8f3", "task_id": "v11_osc_sort_002", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1: tuple, pair2: tuple) -> int:\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower().localecompare(pair2[0].lower())\n        return pair1[1] - pair2[1]\n\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 7}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_1780a61da69a", "task_id": "v11_osc_heap_022", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 8}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_ea03f9d80cc0", "task_id": "v11_osc_interval_merge_007", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 9}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_7044b0fea738", "task_id": "v11_osc_heap_003", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 10}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_0521f45fcf9d", "task_id": "v11_osc_heap_025", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 11}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_7bd38a69d094", "task_id": "v11_osc_interval_merge_011", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 12}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_43c7ab1a70d7", "task_id": "v11_osc_string_match_014", "topic": "string_match", "allowed_approaches": ["kmp", "rabin_karp", "naive", "builtin"], "heuristic_label": "builtin", "code": "from itertools import count\n\ndef find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    i = 0\n    for _ in count():\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices", "sample_id": 13}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_a482bb14981c", "task_id": "v11_osc_sort_025", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 14}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_a7be57b396e5", "task_id": "v11_osc_sort_010", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] - pair2[1]  # Corrected comparison logic\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 15}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_3e1af4ef7ec6", "task_id": "v11_osc_sort_015", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] - pair2[1]  # Corrected comparison logic\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 16}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_805bd06a0cef", "task_id": "v11_osc_interval_merge_014", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda x, y: x[0] - y[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 17}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_f22418b00966", "task_id": "v11_osc_interval_merge_012", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 18}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_a1a2d8b8e800", "task_id": "v11_osc_search_013", "topic": "search", "allowed_approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"], "heuristic_label": "bisect_module", "code": "from bisect import bisect_left\n\ndef binary_search(nums: list[int], target: int) -> int:\n    index = bisect_left(nums, target)\n    if index < len(nums) and nums[index] == target:\n        return index\n    return -1", "sample_id": 19}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_49e913713020", "task_id": "v11_osc_interval_merge_022", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 20}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_4f0d05d3d856", "task_id": "v11_osc_sort_008", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1: tuple, pair2: tuple) -> int:\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower().localecompare(pair2[0].lower())\n        return pair1[1] - pair2[1]\n\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 21}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_065ca72fedc0", "task_id": "v11_osc_topological_sort_018", "topic": "topological_sort", "allowed_approaches": ["dfs_postorder", "kahns_bfs", "recursive"], "heuristic_label": "kahns_bfs", "code": "from collections import defaultdict\n\ndef topo_sort(graph: dict) -> list:\n    in_degree = defaultdict(int)\n    for node in graph:\n        for nbr in graph[node]:\n            in_degree[nbr] += 1\n\n    queue = [node for node in graph if in_degree[node] == 0]\n    order = []\n\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n\n        for nbr in graph[node]:\n            in_degree[nbr] -= 1\n            if in_degree[nbr] == 0:\n                queue.append(nbr)\n\n    return order", "sample_id": 22}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_a91a19cc45b1", "task_id": "v11_osc_sort_016", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] - pair2[1]  # Corrected comparison logic\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 23}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_6b6ec5c4bec7", "task_id": "v11_osc_interval_merge_009", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 24}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_fa881349e9e3", "task_id": "v11_osc_interval_merge_009", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 25}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_e8f644cd3e3d", "task_id": "v11_osc_interval_merge_002", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 26}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_58b7d28bf4e8", "task_id": "v11_osc_string_match_006", "topic": "string_match", "allowed_approaches": ["kmp", "rabin_karp", "naive", "builtin"], "heuristic_label": "builtin", "code": "from typing import List\n\ndef find_all_indices(text: str, pattern: str) -> List[int]:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern)\n    return indices", "sample_id": 27}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_c19d2b399eb1", "task_id": "v11_osc_heap_011", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] < self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] < self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 28}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_737fa9f40b5d", "task_id": "v11_osc_trie_017", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False  # New attribute to track word completion\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True  # Mark the last node as a complete word\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word  # Check if the last node is marked as a word", "sample_id": 29}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_be366ef9bee3", "task_id": "v11_osc_sort_014", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 30}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_c7fe7339aee5", "task_id": "v11_osc_interval_merge_024", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda x, y: x[0] - y[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 31}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_fc43cff47d10", "task_id": "v11_osc_search_019", "topic": "search", "allowed_approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"], "heuristic_label": "bisect_module", "code": "from bisect import bisect_left\n\ndef binary_search(nums: list[int], target: int) -> int:\n    index = bisect_left(nums, target)\n    if index < len(nums) and nums[index] == target:\n        return index\n    return -1", "sample_id": 32}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_a7be57b396e5", "task_id": "v11_osc_sort_010", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 33}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_9969e7cdc122", "task_id": "v11_osc_heap_002", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] < self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] < self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 34}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_fce8f3025ab8", "task_id": "v11_osc_heap_002", "topic": "heap", "allowed_approaches": ["heapq", "manual_sift", "sorted_list"], "heuristic_label": "manual_sift", "code": "class MinHeap:\n    def __init__(self):\n        self.data = []\n\n    def push(self, value: int):\n        self.data.append(value)\n        self._sift_up(len(self.data) - 1)\n\n    def pop(self):\n        if not self.data:\n            return None\n        if len(self.data) == 1:\n            return self.data.pop()\n        root = self.data[0]\n        self.data[0] = self.data.pop()\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx: int):\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if self.data[parent] > self.data[idx]:  # Change comparison operator\n                self.data[parent], self.data[idx] = self.data[idx], self.data[parent]\n                idx = parent\n            else:\n                break\n\n    def _sift_down(self, idx: int):\n        n = len(self.data)\n        while True:\n            left = idx * 2 + 1\n            right = idx * 2 + 2\n            smallest = idx\n            if left < n and self.data[left] > self.data[smallest]:  # Change comparison operator\n                smallest = left\n            if right < n and self.data[right] > self.data[smallest]:  # Change comparison operator\n                smallest = right\n            if smallest == idx:\n                break\n            self.data[idx], self.data[smallest] = self.data[smallest], self.data[idx]\n            idx = smallest", "sample_id": 35}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_69b75fe6bc18", "task_id": "v11_osc_trie_006", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 36}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_5bbd70302d7b", "task_id": "v11_osc_string_match_006", "topic": "string_match", "allowed_approaches": ["kmp", "rabin_karp", "naive", "builtin"], "heuristic_label": "builtin", "code": "from typing import List\n\ndef find_all_indices(text: str, pattern: str) -> List[int]:\n    indices = []\n    i = 0\n    while i < len(text):\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + 1  # Corrected to avoid overlap\n    return indices", "sample_id": 37}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_d11f0e853b72", "task_id": "v11_osc_sort_004", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 38}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_97ba70d07395", "task_id": "v11_osc_search_023", "topic": "search", "allowed_approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"], "heuristic_label": "binary_iterative", "code": "def binary_search(nums: list[int], target: int) -> int:\n    low, high = 0, len(nums) - 1\n    while low <= high:  # <= instead of <\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1", "sample_id": 39}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_bf950e63c6d4", "task_id": "v11_osc_trie_005", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 40}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q4_k_m", "run_id": "run_0b16d268a62e", "task_id": "v11_osc_trie_013", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 41}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_c05c8b9d72ef", "task_id": "v11_osc_trie_012", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 42}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_76e4807e677e", "task_id": "v11_osc_trie_001", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 43}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_514b981deadd", "task_id": "v11_osc_interval_merge_019", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 44}
{"run_dir": "runs/zzz_qwen2_5_coder_7b_instruct_q6_k", "run_id": "run_fc19ae88d477", "task_id": "v11_osc_sort_007", "topic": "sorting", "allowed_approaches": ["quicksort", "mergesort", "builtin", "iterative"], "heuristic_label": null, "code": "from functools import cmp_to_key\n\ndef sort_pairs(pairs: list[tuple]) -> list[tuple]:\n    def compare(pair1, pair2):\n        if pair1[1] == pair2[1]:\n            return pair1[0].lower() < pair2[0].lower()\n        return pair1[1] < pair2[1]\n    pairs.sort(key=cmp_to_key(compare))\n    return pairs", "sample_id": 45}
{"run_dir": "runs/zzz_deepseek_coder_6_7b_instruct_Q6_K", "run_id": "run_6d2135eba3f9", "task_id": "v11_osc_trie_008", "topic": "trie", "allowed_approaches": ["dict_children", "array_children", "defaultdict", "nested_dict"], "heuristic_label": "dict_children", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word", "sample_id": 46}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_7df49e85d456", "task_id": "v11_osc_search_010", "topic": "search", "allowed_approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"], "heuristic_label": "bisect_module", "code": "from bisect import bisect_left\n\ndef binary_search(nums: list[int], target: int) -> int:\n    index = bisect_left(nums, target)\n    if index < len(nums) and nums[index] == target:\n        return index\n    return -1", "sample_id": 47}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_c894e1d40525", "task_id": "v11_osc_interval_merge_007", "topic": "interval_merge", "allowed_approaches": ["sort_and_scan", "sweep_line", "reduce"], "heuristic_label": "sort_and_scan", "code": "from functools import cmp_to_key\n\ndef merge_intervals(intervals: list[tuple]) -> list[tuple]:\n    if not intervals:\n        return []\n    # Sort intervals by start time\n    intervals.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\n    merged = [list(intervals[0])]\n    for start, end in intervals[1:]:\n        last = merged[-1]\n        if start <= last[1]:\n            last[1] = max(last[1], end)\n        else:\n            merged.append([start, end])\n    return [tuple(x) for x in merged]", "sample_id": 48}
{"run_dir": "runs/zzz_codegemma_7b_it_Q6_K", "run_id": "run_e6209ace58a2", "task_id": "v11_osc_search_023", "topic": "search", "allowed_approaches": ["binary_iterative", "binary_recursive", "bisect_module", "linear"], "heuristic_label": "bisect_module", "code": "from bisect import bisect_left\n\ndef binary_search(nums: list[int], target: int) -> int:\n    index = bisect_left(nums, target)\n    if index < len(nums) and nums[index] == target:\n        return index\n    return -1", "sample_id": 49}
{"run_dir": "runs/zzz_qwen2_5_coder_3b_instruct_q6_k", "run_id": "run_93e7f972ffbe", "task_id": "v11_osc_string_match_004", "topic": "string_match", "allowed_approaches": ["kmp", "rabin_karp", "naive", "builtin"], "heuristic_label": "builtin", "code": "from itertools import count\n\ndef find_all_indices(text: str, pattern: str) -> list:\n    indices = []\n    for i in count():\n        j = text.find(pattern, i)\n        if j == -1:\n            break\n        indices.append(j)\n        i = j + len(pattern) - 1\n    return indices", "sample_id": 50}
